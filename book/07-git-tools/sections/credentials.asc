[[_credential_caching]]
=== Збереження посвідчення (credential)

(((credentials)))
(((git commands, credential)))
Якщо ви використовуєте протокол SSH для зʼєднання з віддаленими сховищами, то можете використовувати ключ без пароля, що дозволяє безпечно передавати дані без набирання імʼя користувача та паролю.
Втім, це неможливо з HTTP протоколами – кожне зʼєднання потребує імʼя та пароля.
Все стає ще складнішим з двох-кроковою авторизацією: значення, яке треба використати як пароль, випадково згенероване та невимовне.

На щастя, Git має систему посвідчень, яка може тут зарадити.
Щойно встановлений Git пропонує чимало опцій:

* Типова поведінка взагалі нічого не запамʼятовувати.
  Кожне зʼєднання потребує від вас імʼя користувача та пароль.
* Режим ``cache'' зберігає посвідчення в памʼяті визначений термін.
  Жоден пароль не зберігається на диску, та вичищається з памʼяті за 15 хвилин.
* Режим ``store'' зберігає посвідчення до простого текстового файлу на диску, та ніколи не застаріває.
  Це означає, що доки ви не зміните пароль для Git, вам ніколи не доведеться набирати ваші дані знов.
  Недоліком цього методу є те, що ваші паролі зберігаються текстом в простому файлі у домашній директорії.
* Якщо ви використовуєте Mac, Git має режим ``osxkeychain'', який зберігає посвідчення у безпечному ланцюгу ключів (keychain), що є привʼязаним до вашого системного облікового запису.
  Цей метод зберігає посвідчення на диску, і ніколи не застаріває, проте його зашифровано так само, як система зберігає сертифікати HTTPS та автозаповнювачі Safari.
* Якщо ви використовуєте Windows, ви можете встановити помагач (helper) під назвою ``winstore.''
  Це схоже на описаний вище ``osxkeychain'', проте використовує Windows Credential Store для контролю за приватною інформацією.
  Його можна знайти за адресою https://gitcredentialstore.codeplex.com[].

Щоб задати один з цих методів, треба встановити значення налаштування Git:

[source,console]
----
$ git config --global credential.helper cache
----

Деякі з цих помагачів мають опції.
Помагач ``store'' може приймати аргумент `--file <path>`, який задає, куди зберігається текстовий файл (типове значення `~/.git-credentials`).
Помагач ``cache'' приймає опцію `--timeout <секунд>`, яка змінює термін, протягом якого демон працює (типове значення ``900'', тобто 15 хвилин).
Ось приклад, як можна налаштувати помагач ``store'' особистим іменем файлу:

[source,console]
----
$ git config --global credential.helper store --file ~/.my-credentials
----

Git навіть дозволяє налаштувати декілька помагачів.
При пошуку посвідчення для певного хосту, Git зробить запит до них по черзі, та зупиниться при першій відповіді.
При збереженні посвідчень, Git надішле імʼя користувача та пароль до *всіх* помагачів зі списку, і вони самі можуть вибрати, що з ними робити.
Ось як виглядав би `.gitconfig`, якби б у вас був файл посвідчень на зовнішньому носії, проте ви бажали б використати кеш у памʼяті, щоб заощадити набирання, якщо носій не підключено:

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Під капотом

Як все це працює?
Головною командою Git з системи помічників з посвідченнями є `git credential`, яка приймає команду в якості аргументу, а потім ще ввід через stdin.

Можливо це легше зрозуміти за допомогою прикладу.
Припустімо, помагач посвідчень вже налаштовано, та він вже зберіг посвідчення для `mygithost`.
Ось сесія, що використовує команду ``fill'', яка викликається при спробі знайти посвідчення для хосту:

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> Ця команда розпочинає взаємодію.
<2> Відтак Git-credential очікує вводу з stdin.
    Ми кажемо йому що знаємо: протокол та імʼя хосту.
<3> Порожній рядок означає, що ввід завершено, та система посвідчень має відповісти, що вона знає.
<4> Далі Git-credential приймає керування, та пише до stdout інформацію, яку знайшов.
<5> Якщо посвідчень не знайдено, Git запитує в користувача імʼя та пароль, та видає їх назад до stdout, з якого був викликаний (у даному випадку вони підʼєднані до однієї консолі).

Насправді система посвідчень викликає програму, яка відокремлена від власно Git; яку саме залежить від значення налаштування `credential.helper`.
Ось декілька форм, які воно може мати:

[options="header"]
|======
| Значення налаштування | Поведінка
| `foo` | Виконує `git-credential-foo`
| `foo -a --opt=bcd` | Виконує `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Виконує `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Код після `!` передається на виконання до оболонки (shell)
|======

Отже вищеописані помагачі насправді мають назви `git-credential-cache`, `git-credential-store` тощо, та ми можемо їх налаштувати, щоб вони приймали аргументи командного рядка.
Загальна форма для цього ``git-credential-foo [аргументи] <дія>.''
Протокол stdin/stdout такий самий, як для git-credential, проте вони використовують трохи інших набір дій:

* `get` -- це запит пари імені/паролю.
* `store` -- це запит на зберігання набору посвідчень у памʼяті помагача.
* `erase` -- очистити посвідчення для наданих властивостей з памʼяті помагача.

Для дій `store` та `erase` відповідь не потрібна (Git все одно її ігнорує).
Втім, щодо дії `get`, Git дуже зацікавлений у тому, що скаже помагач.
Якщо помагач не знає нічого корисного, він може просто вийти без виводу, проте якщо він щось знає, він має доповнити прийняту інформацію інформацією, яку зберіг.
Вивід сприймається як послідовність виразів присвоєння; будь-що надане замінить те, що Git вже знає.

Ось такий саме приклад, як і попередній, проте пропустимо git-credential та перейдемо відразу до git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> Тут ми кажемо `git-credential-store` зберегти деякі посвідчення: імʼя ``bob'' та пароль ``s3cre7'' мають використовуватись при доступі до `https://mygithost`.
<2> Тепер ми отримаємо це посвідчення.
    Ми надаємо вже відомі частини зʼєднання (`https://mygithost`) та порожній рядок.
<3> `git-credential-store` відпоміває збереженими вище імʼям користувача та паролем.

Ось як виглядає файл `~/git.store`:

[source]
----
https://bob:s3cre7@mygithost
----

Це просто послідовність рядків, кожен з яких містить декорований посвідченням URL.
Помагачі `osxkeychain` та `winstore` використовують локальний формат своїх cховищ, у той час як `cache` використовує власний формат в памʼяті (яку жоден інший процес не може прочитати).

==== Спеціальний кеш посвідчень

Враховуючи, що `git-credentil-store` з друзями є окремими від Git програмами, нескладно зрозуміти, що _будь-яка_ програма може бути помагачем посвідчень Git.
Помагачі, що входять в поставку Git, доречні в багатьох поширених випадках, проте не у всіх.
For example, let's say your team has some credentials that are shared with the entire team, perhaps for deployment.
These are stored in a shared directory, but you don't want to copy them to your own credential store, because they change often.
None of the existing helpers cover this case; let's see what it would take to write our own.
There are several key features this program needs to have:

. The only action we need to pay attention to is `get`; `store` and `erase` are write operations, so we'll just exit cleanly when they're received.
. The file format of the shared-credential file is the same as that used by `git-credential-store`.
. The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.

Once again, we'll write this extension in Ruby, but any language will work so long as Git can execute the finished product.
Here's the full source code of our new credential helper:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Here we parse the command-line options, allowing the user to specify the input file. The default is `~/.git-credentials`.
<2> This program only responds if the action is `get` and the backing-store file exists.
<3> This loop reads from stdin until the first blank line is reached.
    The inputs are stored in the `known` hash for later reference.
<4> This loop reads the contents of the storage file, looking for matches.
    If the protocol and host from `known` match this line, the program prints the results to stdout and exits.

We'll save our helper as `git-credential-read-only`, put it somewhere in our `PATH` and mark it executable.
Here's what an interactive session looks like:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Since its name starts with ``git-'', we can use the simple syntax for the configuration value:

[source,console]
----
$ git config --global credential.helper read-only --file /mnt/shared/creds
----

As you can see, extending this system is pretty straightforward, and can solve some common problems for you and your team.
