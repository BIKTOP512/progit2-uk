=== Зневадження з Git

Git також пропонує декілька утиліт, що допомагають зневаджувати проблеми у вашому проекті.
Через те, що Git розроблено для роботи майже з будь-яким видом проектів, ці інструменти доволі загальні, проте часто можуть допомогти вам відстежити ваду (bug) чи винуватця, коли щось пішло не так.

[[_file_annotation]]
==== Анотація файлу

Якщо ви шукаєте ваду у своєму коді та бажаєте знати, коли вона зʼявилася та чому, анотація файлів часто є найкращим інструментом.
Він показує вам, який коміт востаннє редагував кожен рядок будь-якого файлу.
Отже, якщо ви бачите, що метод у вашому коді має помилку, ви можете анотувати файл за допомогою `git blame`, щоб побачити, коли кожен рядок методу востаннє редагувався та ким.
Цей приклад використовує опцію `-L` щоб обмежити вивід до рядків з 12 до 22:

[source,console]
----
$ git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command("git show #{tree}")
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command("git log #{tree}")
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command("git blame #{path}")
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end
----

Зауважте, що перше поле це часткова SHA-1 коміту, який востаннє змінював цей рядок.
Наступні два поля є отриманими з цього коміту значеннями: імʼя автора та дата створення цього коміту -- отже ви легко можете побачити, хто та коли редагував рядки.
Після цього йде номер рядка та зміст файлу.
Також зверніть увагу на рядки комітів `^4832fe2`: вони означають, що ці рядки були в першому коміті файлу.
Цей коміт був першим, коли файл було додано до проекту, та ці рядки відтоді не змінювались.
Це крапельку дивно, адже тепер ви бачили принаймні три різних значення, в яких Git використовує `^` щоб змінити SHA-1 коміту, проте саме це в даному випадку цей символ і означає.

Інша чудова річ у Git: він не слідкує за перейменуваннями файлів явно.
Він записує знімки та потім намагається збагнути, що було перейменовано сам, вже після перейменування.
Один з цікавих наслідків цього полягає в тому, що ви також можете попросити Git знайти всілякі переміщення коду.
Якщо передати `-C` до `git blame`, Git проаналізує файл, що ви його анотуєте, та спробує зрозуміти, звідки зʼявилися частини коду, якщо вони були скопійовані з іншого місця.
Наприклад, припустімо ви переробляєте файл `GITServerHandler.m` на декілька файлів, один з яких має назву `GITPackUpload.m`.
Якщо виконати `blame` на файлі `GITPackUpload.m` з опцією `-C`, ви можете побачити, звідки зʼявились секції коду:

[source,console]
----
$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)
----

Це дійсно корисно.
Зазвичай, ви отримуєте першим комітом той коміт, з якого ви скопіювали код, адже це перший раз, коли ви змінювали ці рядки у цьому файлі.
Git повідомляє вам перший коміт, в якому ви написали ці рядки, навіть якщо це сталося в іншому файлі.

[[_binary_search]]
==== Двійковий пошук

Щоб анотування файлу допомогло, треба щоб ви спочатку знали, де проблема.
Якщо ви не знаєте, що зламалося, і було зроблено десятки або сотні комітів відтоді як ви точно знали, що код працював, ви напевно звернетесь до `bisect` по допомогу.
Команда `bisect` виконує двійковий пошук у вашій історії комітів, щоб допомогти вам визначити якомога швидше, який коміт спричинив проблему.

Скажімо, ви щойно виклали ваш готовий код до виробничого середовища, та отримуєте звіти вад про щось, чого не було у вашому середовищі розробки, і ви гадки не маєте, чому код так себе поводить.
Ви повертаєтесь до свого коду, і виявляється, що ви можете відтворити проблему, проте не можете зрозуміти, що працює не так.
Ви розділяєте свій код навпіл (bisect), щоб зʼясувати це.
Спочатку виконуємо `git bisect start`, щоб розпочати процес, потім скористаємося `git bisect bad`, щоб повідомити системі, що поточний коміт зламаний.
Потім, ви маєте повідомити `bisect`, коли востаннє був відомий гарний стан за допомогою `git bisect good [good_commit]`:

[source,console]
----
$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo
----

Git зʼясував, що було зроблено приблизно 12 комітів між позначиним як останній гарний коміт (v1.0) та поточною поганою версією, та отримав (checked out) середній для вас.
Наразі, ви можете виконати ваші тести, щоб дізнатись, чи існує проблема в цьому коміті.
Якщо існує, то вона виникла десь до цього середнього коміту; якщо ж ні, то проблема виникла після середнього коміту.
Виявляється, що тут проблеми немає, і ми кажемо про це Git за допомогою `git bisect good`, та продовжуємо свою подорож:

[source,console]
----
$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing
----

Тепер ви на іншому коміті, посередині між щойно протестованим та вашим поганим комітом.
Ви виконуєте тести знов, та зʼясовуєте, що цього разу коміт зламаний, отже ви кажете про це Git за допомогою `git bisect bad`:

[source,console]
----
$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table
----

Цей коміт у порядку, і тепер Git має всю необхідну інформацію, щоб визначити, де виникла проблема.
Він повідомляє вам SHA-1 першого поганого коміту, та показує деяку інформацію про коміт та які файли було змінено в цьому коміті, щоб ви могли дізнатися, що такого сталося, що могло спричинити цю ваду:

[source,console]
----
$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett <pjhyett@example.com>
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config
----

Коли ви завершили, треба виконати `git bisect reset`, щоб повернути HEAD туди, де ви були спочатку, інакше ви опинитесь у дивному становищі:

[source,console]
----
$ git bisect reset
----

Це могутній інструмент, що може допомогти перевірити сотні комітів на наявність вади за хвилини.
Насправді, якщо у вас є скрипт, що поверне 0, якщо проект у гарному стані, та не 0, якщо у поганому, то можливо повністю автоматизувати `git bisect`.
Спершу, ви знову повідомляєте проміжок `bisect`: задаєте відомі гарний та поганий коміти.
Це можна зробити, якщо додати їх до команди `bisect start`, якщо бажаєте: наведіть відомий поганий коміт першим, а відомий гарний коміт другим:

[source,console]
----
$ git bisect start HEAD v1.0
$ git bisect run test-error.sh
----

Це автоматично виконає `test-error.sh` на кожному отриманому коміті, доки Git не знайде перший зламаний коміт.
Ви також можете виконати щось на кшталт `make` або `make test` чи що завгодно, що виконує автоматичні тести для вас.
