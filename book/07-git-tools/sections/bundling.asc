[[_bundling]]
=== Пакування

Хоч ми й розглянули звичайні способи передачі даних через мережу (HTTP, SSH тощо), насправді існує ще один, не такий поширений, метод зробити це, що іноді може бути доволі корисним.

Git здатен до ``пакування'' (bundling) свої дані в один файл. Це може бути корисним у різноманітних випадках. Можливо, ваша мережа не працює, а ви бажаєте відправити свої зміни співробітникам. Мабуть, ви працюєте десь поза офісом, та не маєте доступу до локальної мережі через заходи безпеки. Можливо, ваша мережева картка просто зламалась. Можливо, наразі у вас немає доступу до спільного сервера, ви бажаєте надіслати електронного листа з оновленнями, проте не бажаєте відправляти 40 комітів через `format-patch`.

Ось тоді команда `git bundle` може допомогти. Команда `bundle` упакує все, що зазвичай передається через дріт командою `git push`, у двійковий файл, який ви можете передати поштою або записати на флеш-накопичувач, а потім розпакувати його в інший репозиторій.

Розгляньмо простий приклад. Скажімо, у вас є репозиторій з двома комітами:

[source,console]
----
$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit
----

Якщо ви бажаєте відправити цей репозиторій комусь, проте не маєте туди доступу на запис, або просто не бажаєте налаштовувати доступ, ви можете упакувати його за допомогою `git bundle create`.

[source,console]
----
$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)
----

Тепер у вас є файл `repo.bundle`, що містить всі необхідні для відтворення гілки `master` дані. Вам необхідно надати команді `bundle` кожне посилання або низку комітів, які ви бажаєте включити. Якщо ви збираєтесь таким чином створювати клон, ви маєте також додати до посилань HEAD, як ми тут зробили.

Ви можете відправити файл `repo.bundle` електронною поштою комусь, або скопіювати його на USB накопичувач та віднести кудись.

З іншого боку, припустимо, що вам надіслали цей файл `repo.bundle`, та ви бажаєте попрацювати над проектом. Ви можете створити клон з цього двійкового файлу в директорію, ніби з URL.

[source,console]
----
$ git clone repo.bundle repo
Initialized empty Git repository in /private/tmp/bundle/repo/.git/
$ cd repo
$ git log --oneline
9a466c5 second commit
b1ec324 first commit
----

Якщо ви не включили HEAD до посилань, ви маєте також додати опцію `-b master` чи будь-яку включену гілку, адже інакше Git не знатиме на яку гілку переключатись.

Тепер припустімо, що ви створюєте три коміти у цій гілці та бажаєте відправити нові коміти назад за допомогою пакунку через електронну пошту або за допомогою USB накопичувача.

[source,console]
----
$ git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit
----

First we need to determine the range of commits we want to include in the bundle. Unlike the network protocols which figure out the minimum set of data to transfer over the network for us, we'll have to figure this out manually.  Now, you could just do the same thing and bundle the entire repository, which will work, but it's better to just bundle up the difference - just the three commits we just made locally.

In order to do that, you'll have to calculate the difference. As we described in <<_commit_ranges>>, you can specify a range of commits in a number of ways. To get the three commits that we have in our master branch that weren't in the branch we originally cloned, we can use something like `origin/master..master` or `master ^origin/master`. You can test that with the `log` command.

[source,console]
----
$ git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
----

So now that we have the list of commits we want to include in the bundle, let's bundle them up. We do that with the `git bundle create` command, giving it a filename we want our bundle to be and the range of commits we want to go into it.

[source,console]
----
$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)
----

Now we have a `commits.bundle` file in our directory. If we take that and send it to our partner, she can then import it into the original repository, even if more work has been done there in the meantime.

When she gets the bundle, she can inspect it to see what it contains before she imports it into her repository.  The first command is the `bundle verify` command that will make sure the file is actually a valid Git bundle and that you have all the necessary ancestors to reconstitute it properly.

[source,console]
----
$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay
----

If the bundler had created a bundle of just the last two commits they had done, rather than all three, the original repository would not be able to import it, since it is missing requisite history.  The `verify` command would have looked like this instead:

[source,console]
----
$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo
----

However, our first bundle is valid, so we can fetch in commits from it.  If you want to see what branches are in the bundle that can be imported, there is also a command to just list the heads:

[source,console]
----
$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
----

The `verify` sub-command will tell you the heads as well.  The point is to see what can be pulled in, so you can use the `fetch` or `pull` commands to import commits from this bundle.  Here we'll fetch the 'master' branch of the bundle to a branch named 'other-master' in our repository:

[source,console]
----
$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -> other-master
----

Now we can see that we have the imported commits on the 'other-master' branch as well as any commits we've done in the meantime in our own 'master' branch.

[source,console]
----
$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit
----

So, `git bundle` can be really useful for sharing or doing network-type operations when you don't have the proper network or shared repository to do so.
