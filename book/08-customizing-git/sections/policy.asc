[[_an_example_git_enforced_policy]]
=== An Example Git-Enforced Policy

(((policy example)))
У цьому розділі ви використовуватимете те, що вивчили для встановлення Git-процесу, що перевірятиме формат певного повідомлення коміту, а також дозволятиме лише вибраним користувачам змінювати певні піддиректорії в проекті.
In this section, you'll use what you've learned to establish a Git workflow that checks for a custom commit message format, and allows only certain users to modify certain subdirectories in a project.
Ви побудуєте клієнтський скрипти, які допомагатимуть розробникові дізнатись чи їх пуш запит буде відхилений, і серверні скрипти, які будуть змушувати дотримуватись політики користування.
You'll build client scripts that help the developer know if their push will be rejected and server scripts that actually enforce the policies.

Скрипти, які ми продемонструємо, написані на Рубі; частково через нашу інтелектувальну інертність, а частково тому, що Рубі читабельна, навіть якщо ви не можете на ній нічого написати.
The scripts we'll show are written in Ruby; partly because of our intellectual inertia, but also because Ruby is easy to read, even if you can't necessarily write it.

However, any language will work – all the sample hook scripts distributed with Git are in either Perl or Bash, so you can also see plenty of examples of hooks in those languages by looking at the samples.
Втім, будь-яка мова підійде - всі приклади хук-скриптів поширювані з Git, написані на Perl чи Bash, тому ви можете знайти в зразках багато прикладів хуків на цих мовах.

==== Server-Side Hook

Вся серверна частина потрапить в `update` файл в вашій `hooks` директорії.
All the server-side work will go into the `update` file in your `hooks` directory.
`update` хук виконується один раз на гілку, коли зміни надсилаються, і приймає три аргументи:
The `update` hook runs once per branch being pushed and takes three arguments:

* Ім’я посилання, до якого надсилаються зміни
* The name of the reference being pushed to
* Стара ревізія, де ця гілка була
* The old revision where that branch was
* Нова ревізія, яка надсилається
* The new revision being pushed

У вас також є доступ до користувача, який надсилає зміни, якщо цей пуш-запит відбуваєтсья через SSH.
You also have access to the user doing the pushing if the push is being run over SSH.
Якщо ви дозволили з’єднання кожному як один користувач (як ``git'') через публічний ключ автентифікації, вам необхідно буде дати цьому юзерові shell обкладинку, яка визначатиме юзера, який буде підключатись на підставі публічного ключа, і відповідно визначати змінну середовища.
If you've allowed everyone to connect with a single user (like ``git'') via public-key authentication, you may have to give that user a shell wrapper that determines which user is connecting based on the public key, and set an environment variable accordingly.
Тут ми припустимо, що юзер, який під’єднуєтсья знайходиться в змінній середовища `$USER`, так що ваш скрипт оновлення починає з збирання усієї необхідної вам інформації:
Here we'll assume the connecting user is in the `$USER` environment variable, so your update script begins by gathering all the information you need:

[source,ruby]
----
#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"
----

Так, це глобальні змінні.
Yes, those are global variables.
Не судіть - так легше продемонструвати.
Don't judge – it's easier to demonstrate this way.

[[_enforcing_commit_message_format]]
===== Enforcing a Specific Commit-Message Format

Ваше перше випробування складається в тому, щоб змусити кожне коміт повідомлення відповідати специфічному форматові.
Your first challenge is to enforce that each commit message adheres to a particular format.
Для прикладу, припустіть, що кожне повідомлення має включати стрінг, який виглядає так ``ref: 1234'', тому що ви хочете кожен коміт прив’язати до робочого елементу в вашій системі керування завданнями.
Just to have a target, assume that each message has to include a string that looks like ``ref: 1234'' because you want each commit to link to a work item in your ticketing system.
Вам необхідно подивитись на кожен коміт, що надсилається, перевірити чи цей стрінг є в коміт повідомленні, і якщо цей стрінг відсутній в цих повідомленнях, то вийти з 'non-zero', щоб цей пуш був відхилений.
You must look at each commit being pushed up, see if that string is in the commit message, and, if the string is absent from any of the commits, exit non-zero so the push is rejected.

Ви можете дістати список SHA-1 значень усіх комітів, які надсилаються, взявши `$newrev` і `$oldrev` значення і передавши їх в Git пламбінг команду, яка називається `git rev-list`.
You can get a list of the SHA-1 values of all the commits that are being pushed by taking the `$newrev` and `$oldrev` values and passing them to a Git plumbing command called `git rev-list`.
Це фактично `git log` команда, але по-замовчуванню вона друкує лише SHA-1 значення і ніякої іншої інформації.
This is basically the `git log` command, but by default it prints out only the SHA-1 values and no other information.
Отже, щоб отримати список усіх проміжних SHA-1 комітів між одним і іншим, ви можете виконнати щось подібне до цього:
So, to get a list of all the commit SHA-1s introduced between one commit SHA-1 and another, you can run something like this:

[source,console]
----
$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475
----

Ви можете взяти цей вивід, пройтись по кожному з цих SHA-1 комітів, взяти повідомлення для нього, і протестуати це повідомленя за допомогою регулярних виразів, які шукатимуть відповідний паттерн.
You can take that output, loop through each of those commit SHA-1s, grab the message for it, and test that message against a regular expression that looks for a pattern.

Вам необхідно дізнатись як отримати коміт повідомлення з кожного з цих комітів для тестування.
You have to figure out how to get the commit message from each of these commits to test.
Для того щоб отримати сирві данні коміту, ви можете використовуати іншу пламбінг команду, яка називається `git cat-file`.
To get the raw commit data, you can use another plumbing command called `git cat-file`.
Ми пройдемось по цих пламбінг командах детальніше в <<_git_internals>>; тим часом, ось що ця команда виводить:
We'll go over all these plumbing commands in detail in <<_git_internals>>; but for now, here's what that command gives you:

[source,console]
----
$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

changed the version number
----

Простим шляхом отримання коміт повідомлення з коміту, коли ви маєте його SHA-1 значення, являється перейди до першої порожнього стрічки і взяти все після неї.
A simple way to get the commit message from a commit when you have the SHA-1 value is to go to the first blank line and take everything after that.
Ви можете так зробити з `sed` командою на Юніксових системах:
You can do so with the `sed` command on Unix systems:

[source,console]
----
$ git cat-file commit ca82a6 | sed '1,/^$/d'
changed the version number
----

Ви можете використовувати ті чари для того, щоб отримати коміт повідомлення з кожного коміту, що пушиться і вийти якщо ви не бачите нічого що б співпало.
You can use that incantation to grab the commit message from each commit that is trying to be pushed and exit if you see anything that doesn't match.
Для того щоб покинути скрипт і відхилити пуш, вийдіть 'non-zero'.
To exit the script and reject the push, exit non-zero.
Весь метод виглядає так:
The whole method looks like this:

[source,ruby]
----
$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format
----

Якщо ви покладете це в ваш `update` скрипт, то він відхилить оновлення, які містять коміти з повідомленнями, що не відповідають вашому правилу.
Putting that in your `update` script will reject updates that contain commits that have messages that don't adhere to your rule.

===== Enforcing a User-Based ACL System

Припустимо, що ви хочете додати маханізм, який використовує контрольний список доступу (ACL - access control list), що визначає яким користувачам дозволяється надсилати зміни в які частини вашого проекту.
Suppose you want to add a mechanism that uses an access control list (ACL) that specifies which users are allowed to push changes to which parts of your projects.
Деякі корисутвачі мають повний доступ, а інші можуть надсилати зміни лише в певні піддерикторії чи до певних файлів.
Some people have full access, and others can only push changes to certain subdirectories or specific files.
Для того щоб це закріпити, ви запишете ці правила в файл, який називається `acl` і який живе у вашому порожньому Git репозиторії на сервері.
To enforce this, you'll write those rules to a file named `acl` that lives in your bare Git repository on the server.
`update` хук буде дивитись на ті правила, визначати, які файли були запропоновані з усіма комітами, які надсилаються, і визначити чи користувач, що робить пуш, має доступ для того щоб оновити всі ті файли.
You'll have the `update` hook look at those rules, see what files are being introduced for all the commits being pushed, and determine whether the user doing the push has access to update all those files.

Перше що ви зробите, ви запишете ваші ACL.
The first thing you'll do is write your ACL.
Тут ви використаєте формат дуже схожий на CVS ACL маханізм: він використовує серії стрічок, де перше поле є `avail` чи `unavail`, настпуне поле є список користувачів, розділених комою, до яких це правило може бути примінене, і останнє поле є шлях, до якого правило приміняється (порожнє означає відкритий доступ).
Here you'll use a format very much like the CVS ACL mechanism: it uses a series of lines, where the first field is `avail` or `unavail`, the next field is a comma-delimited list of the users to which the rule applies, and the last field is the path to which the rule applies (blank meaning open access).
Усі ці поля розділені знаком вертикальної лінії (`|`).
All of these fields are delimited by a pipe (`|`) character.

В цьому випадку, у вас є декілька адміністраторів, де-які письменники документації з доступом до директорії `doc`, і один розробник, який має доступ лише до директорій `lib і `tests`, і ваш ACL файл викладає так:
In this case, you have a couple of administrators, some documentation writers with access to the `doc` directory, and one developer who only has access to the `lib` and `tests` directories, and your ACL file looks like this:

[source]
----
avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests
----

Ви починаєте з читання цих данних в структуру, яку зможете використовувати.
You begin by reading this data into a structure that you can use.
В цьому випадку, щоб не ускладнювати приклад, ви спонукатимете лише директиви `avail`.
In this case, to keep the example simple, you'll only enforce the `avail` directives.
Ось метод, що дає вам асоціативний масив, де ключ це ім’я користувача, а значення це масив шляхів, до яких користувач має доступ write.
Here is a method that gives you an associative array where the key is the user name and the value is an array of paths to which the user has write access:

[source,ruby]
----
def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] << path
    end
  end
  access
end
----


On the ACL file you looked at earlier, this `get_acl_access_data` method returns a data structure that looks like this:

[source,ruby]
----
{"defunkt"=>[nil],
 "tpw"=>[nil],
 "nickh"=>[nil],
 "pjhyett"=>[nil],
 "schacon"=>["lib", "tests"],
 "cdickens"=>["doc"],
 "usinclair"=>["doc"],
 "ebronte"=>["doc"]}
----

Зараз, коли ви дізнались доступи, вам потрібно визначити, які шляхи змінюють коміти, що надсилаються, щоб ви могли упевнетись, що користувач який надсилає зміни має доступ до них усіх.
Now that you have the permissions sorted out, you need to determine what paths the commits being pushed have modified, so you can make sure the user who's pushing has access to all of them.

Ви можете дуже просто побачити які файли були змінені в одному коміті з опцією `--name-only` до `git log` команди (згадана коротко в Розділі 2):
You can pretty easily see what files have been modified in a single commit with the `--name-only` option to the `git log` command (mentioned briefly in Chapter 2):

[source,console]
----
$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb
----

Якщо ви використовуєте структуру ACL, яка повертається `get_acl_access_data` методом і використаєте її для списку файлів в кожному коміті, ви можете визначити чи користува має доступ надсилати всі їхні коміти:
If you use the ACL structure returned from the `get_acl_access_data` method and check it against the listed files in each of the commits, you can determine whether the user has access to push all of their commits:

[source,ruby]
----
# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms
----

Ви отримуєте список нових комітів, які надсилаються до вашого серверу з `git rev-list`.
You get a list of new commits being pushed to your server with `git rev-list`.
Потім, для кожного з цих комітів ви знаходите які файли змінені і запевнюєтесь що користувач, який надсилає має доступ до всіх шляхів, які змінюються.
Then, for each of those commits, you find which files are modified and make sure the user who's pushing has access to all the paths being modified.

Тепер ваші користувачі не можуть надсилати будь-які коміти з погано зформульованими повідомленнями чи з зміненими файлами, які не належать до їхніх визначених шляхів.
Now your users can't push any commits with badly formed messages or with modified files outside of their designated paths.

===== Testing It Out

Якщо ви виконаєте `chmod u+x .git/hooks/update`, що являється файло в який ви мали б покласти увесь цей код, і потім спробуєте надіслати коміт з відповідним повідомленням ви отрмаєте щось подібне до цього:
If you run `chmod u+x .git/hooks/update`, which is the file into which you should have put all this code, and then try to push a commit with a non-compliant message, you get something like this:

[source,console]
----
$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----

Тут є декілька цікавих речей.
There are a couple of interesting things here.
По-перше, ви бачите де хук починає виконуватись.
First, you see this where the hook starts running.

[source]
----
Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)
----

Пам’ятаєте ви видрукували це на самому початку вашого скрипту оновлення.
Remember that you printed that out at the very beginning of your update script.
Все що скрипт відлунює в `stdout` буде передано до клієнта.
Anything your script echoes to `stdout` will be transferred to the client.

Наступні річ, яку ви помітете це повідомлення про помилку.
The next thing you'll notice is the error message.

[source]
----
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
----

Перша стрічка була видрукувана вами, інші дві були від Git, який каже вам, що скрипт оновлення вийшов з не-нуль і що він відхиляє ваш пуш.
The first line was printed out by you, the other two were Git telling you that the update script exited non-zero and that is what is declining your push.
Накінец ви маєте це:
Lastly, you have this:

[source]
----
To git@gitserver:project.git
 ! [remote rejected] master -> master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'
----


You'll see a remote rejected message for each reference that your hook declined, and it tells you that it was declined specifically because of a hook failure.

Furthermore, if someone tries to edit a file they don't have access to and push a commit containing it, they will see something similar.
For instance, if a documentation author tries to push a commit modifying something in the `lib` directory, they see

[source]
----
[POLICY] You do not have access to push to lib/test.rb
----

From now on, as long as that `update` script is there and executable, your repository will never have a commit message without your pattern in it, and your users will be sandboxed.

==== Client-Side Hooks

The downside to this approach is the whining that will inevitably result when your users' commit pushes are rejected.
Having their carefully crafted work rejected at the last minute can be extremely frustrating and confusing; and furthermore, they will have to edit their history to correct it, which isn't always for the faint of heart.

The answer to this dilemma is to provide some client-side hooks that users can run to notify them when they're doing something that the server is likely to reject.
That way, they can correct any problems before committing and before those issues become more difficult to fix.
Because hooks aren't transferred with a clone of a project, you must distribute these scripts some other way and then have your users copy them to their `.git/hooks` directory and make them executable.
You can distribute these hooks within the project or in a separate project, but Git won't set them up automatically.

To begin, you should check your commit message just before each commit is recorded, so you know the server won't reject your changes due to badly formatted commit messages.
To do this, you can add the `commit-msg` hook.
If you have it read the message from the file passed as the first argument and compare that to the pattern, you can force Git to abort the commit if there is no match:

[source,ruby]
----
#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end
----

If that script is in place (in `.git/hooks/commit-msg`) and executable, and you commit with a message that isn't properly formatted, you see this:

[source,console]
----
$ git commit -am 'test'
[POLICY] Your message is not formatted correctly
----

No commit was completed in that instance.
However, if your message contains the proper pattern, Git allows you to commit:

[source,console]
----
$ git commit -am 'test [ref: 132]'
[master e05c914] test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)
----

Next, you want to make sure you aren't modifying files that are outside your ACL scope.
If your project's `.git` directory contains a copy of the ACL file you used previously, then the following `pre-commit` script will enforce those constraints for you:

[source,ruby]
----
#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms
----

This is roughly the same script as the server-side part, but with two important differences.
First, the ACL file is in a different place, because this script runs from your working directory, not from your `.git` directory.
You have to change the path to the ACL file from this

[source,ruby]
----
access = get_acl_access_data('acl')
----

to this:

[source,ruby]
----
access = get_acl_access_data('.git/acl')
----

The other important difference is the way you get a listing of the files that have been changed.
Because the server-side method looks at the log of commits, and, at this point, the commit hasn't been recorded yet, you must get your file listing from the staging area instead.
Instead of

[source,ruby]
----
files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`
----

you have to use

[source,ruby]
----
files_modified = `git diff-index --cached --name-only HEAD`
----

But those are the only two differences – otherwise, the script works the same way.
One caveat is that it expects you to be running locally as the same user you push as to the remote machine.
If that is different, you must set the `$user` variable manually.

One other thing we can do here is make sure the user doesn't push non-fast-forwarded references.
To get a reference that isn't a fast-forward, you either have to rebase past a commit you've already pushed up or try pushing a different local branch up to the same remote branch.

Presumably, the server is already configured with `receive.denyDeletes` and `receive.denyNonFastForwards` to enforce this policy, so the only accidental thing you can try to catch is rebasing commits that have already been pushed.

Here is an example pre-rebase script that checks for that.
It gets a list of all the commits you're about to rewrite and checks whether they exist in any of your remote references.
If it sees one that is reachable from one of your remote references, it aborts the rebase.

[source,ruby]
----
#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end
----
This script uses a syntax that wasn't covered in the Revision Selection section of Chapter 6. You get a list of commits that have already been pushed up by running this:

[source,ruby]
----
`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
----

The `SHA^@` syntax resolves to all the parents of that commit.
You're looking for any commit that is reachable from the last commit on the remote and that isn't reachable from any parent of any of the SHA-1s you're trying to push up – meaning it's a fast-forward.

The main drawback to this approach is that it can be very slow and is often unnecessary – if you don't try to force the push with `-f`, the server will warn you and not accept the push.
However, it's an interesting exercise and can in theory help you avoid a rebase that you might later have to go back and fix.
