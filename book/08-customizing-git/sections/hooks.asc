[[_git_hooks]]
=== Гаки (hooks) Git

(((hooks)))
Як і багато інших Систем Керування Версіями, Git має спосіб запускати користувацькі скрипти, коли виконує якісь важливі дії.
Існує дві групи таких гаків: клієнтські та серверні.
Клієнтські гаки викликаються операціями на кшталт збереження коміту та зливання, у той час як серверні гаки виконується під час мережевих операцій на кшталт отримання надісланих змін.
Ви можете використовувати ці гаки з різноманітних причин.

==== Встановлення гаків

Усі гаки зберігаються у піддиректорії `hooks` директорії Git.
У більшості проектів, це `.git/hooks`.
Під час ініціалізації нового репозиторію за допомогою `git init`, Git заповнює директорію гаків купою прикладів скриптів, багато з яких є корисним, а також документують вхідні значення кожного скрипта.
Всі приклади написані як скрипти оболонки, з невеликими додатками на Perl, проте будь-який правильно названий виконанний скрипт спрацює – ви можете писати їх на Ruby чи Python чи на чому забажаєте.
Якщо ви бажаєте використати скрипти, які постачає Git, то треба їх перейменувати; їхні назви закінчуються на `.sample`.

Щоб увімкнути гак, покладіть файл до піддиректорії `hooks` директорії Git, назвіть його відповідно та зробіть виконанним.
Після цього, він має викликатися.
Ми розглянемо тут найголовніші назви файлів гаків.

==== Клієнтські гаки

Існує багато клієнтських гаків.
Це секція розділяє їх на гаки процесу роботи з комітами, процесу роботи з поштою, та все інше.

[NOTE]
====
Важливо зауважити, що клієнтські гаки *не* копіюються, коли ви створюєте клон репозиторію.
Якщо ви бажаєте використовувати ці скрипти для створення примусової політики, то напевно ви бажаєте це зробити з боку сервера; дивіться приклад в <<_an_example_git_enforced_policy>>.
====

===== Гаки процесу роботи з комітами

Перші чотири гаки пов’язані з процесом створення комітів.

Спочатку виконується гак `pre-commit`, навіть перед тим, як ви набрали повідомлення коміту.
Він використовується щоб оглянути відбиток, який ви збираєтесь зберегти в коміті, щоб побачити, чи забули ви щось, переконатись, що тести проходять, чи щоб перевірити будь-що, що вам потрібно в коді.
Вихід з цього гака з не нулем скасовує коміт, хоча щоб цього уникнути за допомогою `git commit --no-verify`.
Ви можете робити такі речі, як перевірка стилю коду (виконати `lint` чи аналог), перевірити пробільні символи наприкінці рядка (типовий гак саме це й робить), чи перевірити відповідність документації новим методам.

Гак `prepare-commit-msg` викликається перед тим, як запускається редактор повідомлення коміту, проте після того, як типове повідомлення створено.
Це дозволяє вам редагувати типове повідомлення перед тим, як автор коміту побачить його.
Цей гак приймає декілька параметрів: шлях до файлу, який містить поточне повідомлення коміту, тип коміту та SHA-1 коміту, якщо це виправлення (amend) коміту.
Цей гак зазвичай не є дуже корисним для нормальних комітів: швидше він є доречним для комітів, для яких типове повідомлення комітів автоматично генеруються, наприклад шаблонні повідомлення комітів, коміти злиття, коміти зварювання та коміти виправлення.
Ви можете використовувати його разом з шаблоном коміту, щоб програмно додати інформацію.

Ufr `commit-msg` приймає один параметр -- знову шлях до тимчасового файлу, який містить повідомлення коміту, яке написав розробник.
Якщо скрипт виходить не з нулем, то Git скасовує коміт, отже ви можете використати його, щоб перевіряти стан або повідомлення коміту перед тим, як дозволити йти далі.
В останній секції цього розділу, ми продемонструємо використання цього гаку для перевірки відповідності повідомлення коміту необхідному взірцю.

Після того, як весь процес коміту завершено, виконується гак `post-commit`.
Він не приймає жодних параметрів, проте ви легко можете отримати останній коміт за допомогою `git log -1 HEAD`.
Зазвичай, цей скрипт використовують для звісток чи чогось схожого.

[[_email_hooks]]
===== E-mail Workflow Hooks

You can set up three client-side hooks for an e-mail-based workflow.
They're all invoked by the `git am` command, so if you aren't using that command in your workflow, you can safely skip to the next section.
If you're taking patches over e-mail prepared by `git format-patch`, then some of these may be helpful to you.

The first hook that is run is `applypatch-msg`.
It takes a single argument: the name of the temporary file that contains the proposed commit message.
Git aborts the patch if this script exits non-zero.
You can use this to make sure a commit message is properly formatted, or to normalize the message by having the script edit it in place.

The next hook to run when applying patches via `git am` is `pre-applypatch`.
Somewhat confusingly, it is run _after_ the patch is applied but before a commit is made, so you can use it to inspect the snapshot before making the commit.
You can run tests or otherwise inspect the working tree with this script.
If something is missing or the tests don't pass, exiting non-zero aborts the `git am` script without committing the patch.

The last hook to run during a `git am` operation is `post-applypatch`, which runs after the commit is made.
You can use it to notify a group or the author of the patch you pulled in that you've done so.
You can't stop the patching process with this script.

[[_other_client_hooks]]
===== Other Client Hooks

The `pre-rebase` hook runs before you rebase anything and can halt the process by exiting non-zero.
You can use this hook to disallow rebasing any commits that have already been pushed.
The example `pre-rebase` hook that Git installs does this, although it makes some assumptions that may not match with your workflow.

The `post-rewrite` hook is run by commands that replace commits, such as `git commit --amend` and `git rebase` (though not by `git filter-branch`).
Its single argument is which command triggered the rewrite, and it receives a list of rewrites on `stdin`.
This hook has many of the same uses as the `post-checkout` and `post-merge` hooks.

After you run a successful `git checkout`, the `post-checkout` hook runs; you can use it to set up your working directory properly for your project environment.
This may mean moving in large binary files that you don't want source controlled, auto-generating documentation, or something along those lines.

The `post-merge` hook runs after a successful `merge` command.
You can use it to restore data in the working tree that Git can't track, such as permissions data.
This hook can likewise validate the presence of files external to Git control that you may want copied in when the working tree changes.

The `pre-push` hook runs during `git push`, after the remote refs have been updated but before any objects have been transferred.
It receives the name and location of the remote as parameters, and a list of to-be-updated refs through `stdin`.
You can use it to validate a set of ref updates before a push occurs (a non-zero exit code will abort the push).

Git occasionally does garbage collection as part of its normal operation, by invoking `git gc --auto`.
The `pre-auto-gc` hook is invoked just before the garbage collection takes place, and can be used to notify you that this is happening, or to abort the collection if now isn't a good time.

==== Server-Side Hooks

In addition to the client-side hooks, you can use a couple of important server-side hooks as a system administrator to enforce nearly any kind of policy for your project.
These scripts run before and after pushes to the server.
The pre hooks can exit non-zero at any time to reject the push as well as print an error message back to the client; you can set up a push policy that's as complex as you wish.

===== `pre-receive`

The first script to run when handling a push from a client is `pre-receive`.
It takes a list of references that are being pushed from stdin; if it exits non-zero, none of them are accepted.
You can use this hook to do things like make sure none of the updated references are non-fast-forwards, or to do access control for all the refs and files they're modifying with the push.

===== `update`

The `update` script is very similar to the `pre-receive` script, except that it's run once for each branch the pusher is trying to update.
If the pusher is trying to push to multiple branches, `pre-receive` runs only once, whereas update runs once per branch they're pushing to.
Instead of reading from stdin, this script takes three arguments: the name of the reference (branch), the SHA-1 that reference pointed to before the push, and the SHA-1 the user is trying to push.
If the update script exits non-zero, only that reference is rejected; other references can still be updated.

===== `post-receive`

The `post-receive` hook runs after the entire process is completed and can be used to update other services or notify users.
It takes the same stdin data as the `pre-receive` hook.
Examples include e-mailing a list, notifying a continuous integration server, or updating a ticket-tracking system – you can even parse the commit messages to see if any tickets need to be opened, modified, or closed.
This script can't stop the push process, but the client doesn't disconnect until it has completed, so be careful if you try to do anything that may take a long time.
