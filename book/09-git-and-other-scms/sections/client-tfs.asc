==== Git та TFS

(((Interoperation with other VCSs, TFS)))
(((TFS)))((("TFVC", see="TFS")))
Git популяризується серед Windows розробників і, якщо ви пишете код "під Windows", то є велика ймовірність, що ви також використовуєте Microsoft's Team Foundation Server (TFS).
TFS є набором інструментів для співпраці, що включає в себе облік дефектів, завдань, підтримку Scrum процесу та інших, перегляд коду, та контроль версій.
Є трохи плутанини: *TFS* -- це сервер, котрий має підтримку контролю коду, користуючись як Git, так і своєю власною СКВ, що має назву *TFVC* (Team Foundation Version Control).
Підтримка Git є дещо новою особливістю для TFS (починаючи з 2013 версії), тому всі інструменти, що передували цій появі, звертаються до частини версіонування коду як ``TFS'', незважаючи на те, що насправді працюють з TFVC.

Якщо ви опинетеся в команді, котра користується TFVC, але краще б надали перевагу Git, як системі контролю версій, то для цього існує готовий проект.

===== Який інструмент

(((git-tf)))(((git-tfs)))
Насправді, їх є два: git-tf та git-tfs.

Git-tfs (можна знайти за https://github.com/git-tfs/git-tfs[]) є .NET проектом та (на момент написання цього тексту) сумісний тільки з Windows.
Для роботи з Git сховищами він використовує .NET обгортку над libgit2, бібліотеко-орієнтованою реалізацією Git, що є високопродуктивною та дозволяє багато гнучкості з нутрощами Git сховища. 
Libgit2 не є повною реалізацією Git, тому git-tfs використовує клієнтську командну стрічку Git для того, щоб закрити недостачу, отже, фактично, немає обмежень в тому, що ця утиліта може робити зі сховищами Git.
Її підтримка особливостей TFVC є достить зрілою через те, що вона оперує з сервером через бібліотеки Visual Studio.
Це значить, що вам потрібен доступ до цих бібліотек, що, в свою чергу означає, що потрібно встановити недавню версію Visual Studio (будь-яку редакцію, починаючи з версії 2010, включно з Express починаючи з 2012), або Visual Studio SDK.

Git-tf (який живе за адресою https://gittf.codeplex.com[]) є Java проектом і через це може працювати на будь-якому комп'ютері з Java середовищем.
Він взаємодіє з Git сховищем через JGit (JVM реалізація Git), тобто, практично не має обмежень щодо функціональності Git.
Проте, робота TFVC не є повною, порівняно з git-tfs – немає підтримки гілок, для прикладу.

Тому, кожен інструмент має свої сильні та слабкі сторони і є різні ситуації, коли треба надати перевагу одному над іншим.
В цій книзі ми розкриємо базове використання обох.

[NOTE]
====
Вам знадобиться доступ до сховища TFVC для того, щоб могти слідувати цим інструкціям. 
А їх не так просто знайти, як, скажімо, сховища Git чи Subversion, тому, можливо, прийдеться створити самому.
Для цієї задачі добре підходять Codeplex (https://www.codeplex.com[]) чи Visual Studio Online (http://www.visualstudio.com[]).
====


===== Ознайомлення з `git-tf`

По-перше, як і з будь-яким іншим Git проектом, склонуймо.
Ось як це виглядає з `git-tf`:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
----

Перший аргумент є URL до TFVC колекцій, другий має формат `$/проект/гілка`, а третій -- це шлях до локального Git сховища, що буде створено (цей аргумент не обов'язковий).
Git-tf може працювати лише з одною гілкою одночасно; якщо ви хочете зробити чекіни (checkins) до іншої гілки TFVC, то склонуйте заново з потрібної гілки.

Ось як створити повнофункціональний Git репозиторій:

[source,console]
----
$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
----

Це зветься _мілким_ (shallow) клоном, в тому значенні, що завантажено лише найостанніший чейнджсет.
TFVC не спроектований таким чином, що кожен клієнт має повну копію історії, тому git-tf типово отримає лише останню версію, а це є значно швидшим.

Коли ж у вас вдосталь часу, мабуть, варто клонувати всю історію проекту, за допомогою опції `--deep`:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard
----

Зверніть увагу на теґи з іменами типу `TFS_C35189`; за допомогою цієї особливості ви дізнаєтеся який Git коміт та чейнджсет TFVC пов'язані між собою.
Це є хорошим відображенням, оскільки ви можете за допомогою простої команди `log` з'ясувати які з ваших комітів також також існують в TFVC.
Ці теґи не є обов'язковими (і їх насправді можна вимкнути за допомогою `git config git-tf.tag false`) – git-tf все одно зберігає реальні зв'язки коміт-чейнджсет у файлі `.git/git-tf`.

===== Ознайомлення з `git-tfs`

Клонування в git-tfs відбувається дещо інакше.
Погляньте:

[source,powershell]
----
PS> git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Зверніть увагу на прапорець `--with-branches`.
Git-tfs має можливість створювати відповідності між гілками TFVC та Git, а цей прапорець вказує на необхідність створювати локальні Git гілки для кожної гілки TFVC.
Його використання є рекомендованим якщо ви збираєтеся робити гілки чи зливати в TFS, проте такий підхід не працюватиме з сервером старішим за TFS 2010 – до цього релізу ``гілки'' були просто теками, тому git-tfs не міг відрізнити їх від звичайних тек.

Погляньте на результуюче Git сховище:

[source,powershell]
----
PS> git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS> git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
----

Маємо дві локальні гілки, `master` та `featureA`, котрі відображають стартову точку клонування (`Trunk` в іменуванні TFVC) та дочірню гілку (`featureA` в TFVC).
Ви можете бачити також, що ``віддалене сховище'' `tfs` має також кілька посилань: `default` та `featureA`, які відображають гілки TFVC.
Git-tfs робить відповідність між клонованою гілкою та `tfs/default`, а також інші отримують свої імена.

Ще варто звернути увагу на `git-tfs-id:` рядки в повідомленнях коміту.
Замість теґів, git-tfs використовує ці позначки для зв'язку між TFVC чейнджсетами та Git комітами.
З цього випливає те, що ваші Git коміти матимуть різні SHA-1 хеші до та після надсилання до TFVC.

===== Процеси роботи Git-tf[s]

[NOTE]
====
Незалежно від того, яким з інстументів ви користуєтеся, налаштуйте ряд конфігураційних значень, задля уникнення неприємностей.

[source,console]
----
$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
----
====

Очевидно, далі ви б хотіли попрацювати над проектом.
TFVC та TFS мають кілька особливостей що можуть ускладнити ваш робочий процес:

. Тематичні гілки, що не мають відображення в TFVC додають складнощів.
  Стається це через *дуже* різний спосіб того, як TFVC та Git тракують гілки.
. Пам'ятайте, що TFVC дозволяє користувачам ``забирати''(checkout) файли з сервера, замикаючи їх так, що більш ніхто не зможе їх редагувати.
  Звичайно, це не є перепоною для роботою з цими файлами у вашому локальному сховищі, але може стати такою, коли прийде час надсилання змін до TFVC сервера.
. TFS має концепцію ``закритих'' ??? (``gated'') чекінів, коли цикл побудова-тести має бути успішно завершеним до того, як дозволено робити чекін.
  Тут використовується функція відкладених комітів ``shelve'' TFVC, яку ми тут детально не розглядатимемо.
    Ви можете сфабрикувати це вручну з git-tf та git-tfs котрі мають команду `checkintool`, що знає про закриті чекіни.

Для стислості, ми розглянемо лише щасливий шлях, що уникає більшість із згаданих нюансів.

===== Workflow: `git-tf`


Let's say you've done some work, made a couple of Git commits on `master`, and you're ready to share your progress on the TFVC server.
Here's our Git repository:

[source,console]
----
$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

We want to take the snapshot that's in the `4178a82` commit and push it up to the TFVC server.
First things first: let's see if any of our teammates did anything since we last connected:

[source,console]
----
$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Looks like someone else is working, too, and now we have divergent history.
This is where Git shines, but we have two choices of how to proceed:

. Making a merge commit feels natural as a Git user (after all, that's what `git pull` does), and git-tf can do this for you with a simple `git tf pull`.
  Be aware, however, that TFVC doesn't think this way, and if you push merge commits your history will start to look different on both sides, which can be confusing.
  However, if you plan on submitting all of your changes as one changeset, this is probably the easiest choice.
. Rebasing makes our commit history linear, which means we have the option of converting each of our Git commits into a TFVC changeset.
  Since this leaves the most options open, we recommend you do it this way; git-tf even makes it easy for you with `git tf pull --rebase`.

The choice is yours.
For this example, we'll be rebasing:

[source,console]
----
$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Now we're ready to make a checkin to the TFVC server.
Git-tf gives you the choice of making a single changeset that represents all the changes since the last one (`--shallow`, which is the default) and creating a new changeset for each Git commit (`--deep`).
For this example, we'll just create one changeset:

[source,console]
----
$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

There's a new `TFS_C35348` tag, indicating that TFVC is storing the exact same snapshot as the `5a0e25e` commit.
It's important to note that not every Git commit needs to have an exact counterpart in TFVC; the `6eb3eb5` commit, for example, doesn't exist anywhere on the server.

That's the main workflow.
There are a couple of other considerations you'll want to keep in mind:

* There is no branching.
  Git-tf can only create Git repositories from one TFVC branch at a time.
* Collaborate using either TFVC or Git, but not both.
  Different git-tf clones of the same TFVC repository may have different commit SHA-1 hashes, which will cause no end of headaches.
* If your team's workflow includes collaborating in Git and syncing periodically with TFVC, only connect to TFVC with one of the Git repositories.


===== Workflow: `git-tfs`

Let's walk through the same scenario using git-tfs.
Here are the new commits we've made to the `master` branch in our Git repository:

[source,powershell]
----
PS> git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
----

Now let's see if anyone else has done work while we were hacking away:

[source,powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Yes, it turns out our coworker has added a new TFVC changeset, which shows up as the new `aea74a0` commit, and the `tfs/default` remote branch has moved.

As with git-tf, we have two fundamental options for how to resolve this divergent history:

. Rebase to preserve a linear history.
. Merge to preserve what actually happened.

In this case, we're going to do a ``deep'' checkin, where every Git commit becomes a TFVC changeset, so we want to rebase.

[source,powershell]
----
PS> git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS> git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Now we're ready to complete our contribution by checking in our code to the TFVC server.
We'll use the `rcheckin` command here to create a TFVC changeset for each Git commit in the path from HEAD to the first `tfs` remote branch found (the `checkin` command would only create one changeset, sort of like squashing Git commits).

[source,powershell]
----
PS> git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS> git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Notice how after every successful checkin to the TFVC server, git-tfs is rebasing the remaining work onto what it just did.
That's because it's adding the `git-tfs-id` field to the bottom of the commit messages, which changes the SHA-1 hashes.
This is exactly as designed, and there's nothing to worry about, but you should be aware that it's happening, especially if you're sharing Git commits with others.

TFS has many features that integrate with its version control system, such as work items, designated reviewers, gated checkins, and so on.
It can be cumbersome to work with these features using only a command-line tool, but fortunately git-tfs lets you launch a graphical checkin tool very easily:

[source,powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

It looks a bit like this:

.The git-tfs checkin tool.
image::images/git-tfs-ct.png[The git-tfs checkin tool.]

This will look familiar to TFS users, as it's the same dialog that's launched from within Visual Studio.

Git-tfs also lets you control TFVC branches from your Git repository.
As an example, let's create one:

[source,powershell]
----
PS> git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Creating a branch in TFVC means adding a changeset where that branch now exists, and this is projected as a Git commit.
Note also that git-tfs *created* the `tfs/featureBee` remote branch, but `HEAD` is still pointing to `master`.
If you want to work on the newly-minted branch, you'll want to base your new commits on the `1d54865` commit, perhaps by creating a topic branch from that commit.


===== Git and TFS Summary

Git-tf and Git-tfs are both great tools for interfacing with a TFVC server.
They allow you to use the power of Git locally, avoid constantly having to round-trip to the central TFVC server, and make your life as a developer much easier, without forcing your entire team to migrate to Git.
If you're working on Windows (which is likely if your team is using TFS), you'll probably want to use git-tfs, since its feature set is more complete, but if you're working on another platform, you'll be using git-tf, which is more limited.
As with most of the tools in this chapter, you should choose one of these version-control systems to be canonical, and use the other one in a subordinate fashion – either Git or TFVC should be the center of collaboration, but not both.
