//=== Contributing to a Project
=== Як Зробити Внесок до Проекту

//Now that our account is set up, let's walk through some details that could be useful in helping you contribute to an existing project.
Тепер, коли ваш обліковий запис налаштовано, розгляномо деякі подробиці, що можуть стати вам у нагоді при роботі над вже існуючим проектом.

//==== Forking Projects
==== Робимо Форк Проекту

(((forking)))
//If you want to contribute to an existing project to which you don’t have push access, you can ``fork'' the project.
Якщо ви бажаєте зробити внесок до існуючого проекту, проте у вас немає права на викладання до нього змін, ви можете створити ``форк'' (`fork`) проекту.
//What this means is that GitHub will make a copy of the project that is entirely yours; it lives in your user's namespace, and you can push to it.
Це означає, що GitHub створить копію проекту, що є повністю вашою. Вона існує в просторі імен вашого користувача, ви можете викладати до неї зміни.

[NOTE]
====
//Historically, the term ``fork'' has been somewhat negative in context, meaning that someone took an open source project in a different direction, sometimes creating a competing project and splitting the contributors.
Історично термін ``форк'' має дещо негативне забарвлення, зазвичай це означало, що хтось узяв проект з відкритим кодом та повів його в іншому напрямку, іноді створюючи конкуруючий проект та забираючи частину розробників.
//In GitHub, a ``fork'' is simply the same project in your own namespace, allowing you to make changes to a project publicly as a way to contribute in a more open manner.
У GitHub ``форк'' - це просто той самий проект у вашому власному просторі імен, що дозволяє вам робити зміни до проекту публічно, це засіб зробити внесок у більш відкритій спосіб.
====

//This way, projects don’t have to worry about adding users as collaborators to give them push access.
Таким чином, проектам не доводиться піклуватися про надання користувачам права на викладання змін.
//People can fork a project, push to it, and contribute their changes back to the original repository by creating what's called a Pull Request, which we'll cover next.
Кожен може створити форк проекту, викласти до нього зміни, та додати свої зміни до оригінального сховища за допомогою ``Запита на Забирання Змін'' (Pull Request), про який ми поговоримо далі.
//This opens up a discussion thread with code review, and the owner and the contributor can then communicate about the change until the owner is happy with it, at which point the owner can merge it in.
Цей запит відкриває нитку дискусії з можливістю переглядати код, власник та автор змін можуть спілкуватися про зміни доки власник не стане ними задоволений, після чого власник може злити зміни до свого сховища.

//To fork a project, visit the project page and click the ``Fork'' button at the top-right of the page.
Щоб зробити форк проекту, зайдіть на сторінку проекту та натисніть на кнопку ``Fork'' зверху праворуч.

//.The ``Fork'' button.
.Кнопка ``Fork''.
image::images/forkbutton.png[Кнопка ``Fork''.]

//After a few seconds, you'll be taken to your new project page, with your own writeable copy of the code.
Через декілька секунд, ви опинитесь на сторінці вашого нового проекту, з вашою власною копією коду, яку ви можете змінювати.


[[_github_flow]]
//==== The GitHub Flow
==== Потік роботи GitHub

(((GitHub, Flow)))
//GitHub is designed around a particular collaboration workflow, centered on Pull Requests.
GitHub був спроектований навколо конкретного методу співпраці, в центрі якого Запит на Пул.
//This flow works whether you're collaborating with a tightly-knit team in a single shared repository, or a globally-distributed company or network of strangers contributing to a project through dozens of forks.
Цей метод працює і в разі співпраці у маленькій команді в одному спільному сховищі, і в глобальній розподіленій компанії, чи мережі незнайомців, які допомагають проекту через десятки форків.
//It is centered on the <<_topic_branch>> workflow covered  in <<_git_branching>>.
Він базується на процесі роботи <<_topic_branch>>, який ми вже розглянули в <<_git_branching>>.


//Here's how it generally works:
Ось як це в цілому працює:

//1. Create a topic branch from `master`.
1. Створіть гілку на основі `master`, в ній ви будете робити всі свої зміни.
//2. Make some commits to improve the project.
2. Зробіть якісь коміти, що поліпшують проект.
//3. Push this branch to your GitHub project.
3. Викладайте цю гілку до свого проекту GitHub.
//4. Open a Pull Request on GitHub.
4. Відкрийте Запит на Пул за допомогою GitHub.
//5. Discuss, and optionally continue committing.
5. Обговоріть зміни, можливо зробіть ще декілька комітів.
//6. The project owner merges or closes the Pull Request.
6. Власник проекту заливає до проекту Запит на Пул, або закриває його.

//This is basically the Integration Manager workflow covered in <<_integration_manager>>, but instead of using email to communicate and review changes, teams use GitHub's web based tools.
Це дуже схоже на процес роботи Integration Manager, який ми розглянули в <<_integration_manager>>, проте замість використання електронної пошти для спілкування та огляду змін, команди використовують інструменти сайту GitHub.

//Let's walk through an example of proposing a change to an open source project hosted on GitHub using this flow.
Детально розглянемо приклад того, як запропонувати зміни до проекту з відкритим кодом, що зберігає код на GitHub, за допомогою цієї схеми.

//===== Creating a Pull Request
===== Створення Запиту на Пул

//Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program file on GitHub at https://github.com/schacon/blink[].
Тоні шукає код, який можна запустити на його мікроконтролері на платі Arduino, та знайшов чудовий програмний файл на GitHub за адресою https://github.com/schacon/blink[].

//.The project we want to contribute to.
.Проект, до якого ми хочемо зробити внесок.
image::images/blink-01-start.png[Проект, до якого ми хочемо зробити внесок.]

//The only problem is that the blinking rate is too fast, we think it's much nicer to wait 3 seconds instead of 1 in between each state change. So let's improve the program and submit it back to the project as a proposed change.
Єдина проблема в тому, що частота миготіння занадто велика, ми гадаємо, що набагато краще чекати 3 секунди замість 1 між кожною зміною стану. Отже ми покращуємо програму та надсилаємо назад до проекту як пропоновану зміну.

//First, we click the 'Fork' button as mentioned earlier to get our own copy of the project. Our user name here is ``tonychacon'' so our copy of this project is at `https://github.com/tonychacon/blink` and that's where we can edit it. We will clone it locally, create a topic branch, make the code change and finally push that change back up to GitHub.
Спочатку, ми натискаємо на кнопку 'Fork', як ми згадували раніше, щоб отримати нашу власну копію проекту. Наше ім'я користувача тут ``tonychacon'', отже наша копія проекту має адресу `https://github.com/tonychacon/blink' і саме за цією адресою ми можемо її редагувати. Ми зробимо локальний клон, створимо гілку для наших змін, зробимо зміни в коді та нарешті викладемо ці зміни назад до GitHub.

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

//<1> Clone our fork of the project locally
<1> Клонуємо наш форк проекту локально
//<2> Create a descriptive topic branch
<2> Створюємо окрему гілку зі зрозумілою назвою
//<3> Make our change to the code
<3> Робимо наші зміни в коді
//<4> Check that the change is good
<4> Перевіряємо, що зміни вірні
//<5> Commit our change to the topic branch
<5> Робимо коміт наших змін до своєї гілки
//<6> Push our new topic branch back up to our GitHub fork
<6> Викладаємо нашу нову гілку назад до нашого форку GitHub.

//Now if we go back to our fork on GitHub, we can see that GitHub noticed that we pushed a new topic branch up and present us with a big green button to check out our changes and open a Pull Request to the original project.
Тепер, якщо ми повернемося до нашого форку на GitHub, ми можемо бачити, що GitHub помітив, що ми виклали нову гілку та виводить нам велику зелену кнопку щоб продивитись наші зміни та відкрити Запит на Пул до оригінального проекту.

//You can alternatively go to the ``Branches'' page at `https://github.com/<user>/<project>/branches` to locate your branch and open a new Pull Request from there.
Також ви можете перейти до сторінки ``Branches'' (гілки) за адресою `https://github.com/<user>/<project>/branches`, щоб знайти вашу гілку та відкрити новий Запит на Пул звідти.

//.Pull Request button
.Кнопка Запит на Пул (Pull Request)
image::images/blink-02-pr.png[Кнопка Запит на Пул (Pull Request)]

(((GitHub, pull requests)))
//If we click that green button, we'll see a screen that allows us to create a title and description for the change we would like to request so the project owner has a good reason to consider it. It is generally a good idea to spend some effort making this description as useful as possible so the author knows why this is being suggested and why it would be a valuable change for them to accept.
Якщо ми натиснемо на цю зелену кнопку, ми побачимо сторінку, що дозволяє нам задати назву та опис зміни, для якої ми бажаємо створити запит, щоб власник проекту міг одразу зрозуміти, що ці зміни варто розглянути. Взагалі це слушна ідея, витратити деякі зусилля, щоб зробити опис якомога корисним, щоби автори знали, чому ці зміни їм пропонують, та чому це буде цінним внеском, який варто прийняти.

//We also see a list of the commits in our topic branch that are ``ahead'' of the `master` branch (in this case, just the one) and a unified diff of all the changes that will be made should this branch get merged by the project owner.
Ми також бачимо список комітів вашої гілки, які ``ahead'' (попереду) гілки `master` (у цьому випадку тільки один) та об'єднану різницю (unified diff) від усіх змін, що будуть зроблені, якщо цю гілку зіллє власник проекту.

//.Pull Request creation page
.Сторінка створення Запиту на Пул
image::images/blink-03-pull-request-open.png[Сторінка створення Запиту на Пул]

//When you hit the 'Create pull request' button on this screen, the owner of the project you forked will get a notification that someone is suggesting a change and will link to a page that has all of this information on it.
Коли ви натиснете кнопку 'Create pull request' (створити запит на пул) на цій сторінці, власник проекту, від якого ви створили форк, отримає повідомлення про те, що хтось пропонує зміни з посиланням на сторінку, що містить усю інформацію про ці зміни.

[NOTE]
====
//Though Pull Requests are used commonly for public projects like this when the contributor has a complete change ready to be made, it's also often used in internal projects _at the beginning_ of the development cycle.  Since you can keep pushing to the topic branch even *after* the Pull Request is opened, it's often opened early and used as a way to iterate on work as a team within a context, rather than opened at the very end of the process.
Хоч Запити на Пул зазвичай використовують у відкритих проектах так, як описано вище - коли зміни вже повністю готові, Запити на Пул також часто використовуються у внутрішніх проектах _на початку_ циклу розробки. Оскільки ви можете продовжувати заливати зміни до гілки навіть *після* відкриття Запиту на Пул, нерідко його відкривають завчасно та використовують як спосіб ітеративного доопрацювання в команді, а не відкривають наприкінці процесу.
====

//===== Iterating on a Pull Request
===== Ітеративне Доопрацювання за допомогою Запита на Пул

//At this point, the project owner can look at the suggested change and merge it, reject it or comment on it. Let's say that he likes the idea, but would prefer a slightly longer time for the light to be off than on.
Тепер власник проекту може подивитися на пропоновані зміни та злити їх з проектом, відмовитись від них або прокоментувати їх. Припустимо, що ідея йому подобається, проте він бажає щоб світлодіод трохи довше був увімкнутим та вимкненим.

//Where this conversation may take place over email in the workflows presented in <<_distributed_git>>, on GitHub this happens online. The project owner can review the unified diff and leave a comment by clicking on any of the lines.
У представленому в <<_distributed_git>> процесі роботи обговорення б проходило через електронну пошту, а на GitHub усе обговорення йде прямо на сайті. Власник проекту може продивлятись об'єднану різницю (unified diff) та залишити коментар, якщо він просто натисне на будь-який з рядків.

//.Comment on a specific line of code in a Pull Request
.Коментування окремого рядка коду в Запиті на Пул
//image::images/blink-04-pr-comment.png[PR line comment]
image::images/blink-04-pr-comment.png[Коментування окремого рядка коду в Запиті на Пул]

//Once the maintainer makes this comment, the person who opened the Pull Request (and indeed, anyone else watching the repository) will get a notification. We'll go over customizing this later, but if he had email notifications turned on, Tony would get an email like this:
Коли супроводжувач (maintainer) зробить цей коментар, людина, що відкрила Запит на Пул (та насправді будь-хто, хто слідкує за сховищем) отримає повідомлення. Ми розглянемо прилаштування цього пізніше, проте якщо в нього були ввімкнені поштові повідомлення, Тоні отримає такого листа:

[[_email_notification]]
//.Comments sent as email notifications
.Коментарі, що їх відправили як поштові повідомлення
//image::images/blink-04-email.png[Email notification]
image::images/blink-04-email.png[Поштове повідомлення]

//Anyone can also leave general comments on the Pull Request. In <<_pr_discussion>> we can see an example of the project owner both commenting on a line of code and then leaving a general comment in the discussion section. You can see that the code comments are brought into the conversation as well.
Хто завгодно може залишати загальні коментарі до Запиту на Пул. У <<_pr_discussion>> ми можемо побачити приклад того, як власник проекту прокоментував і окремий рядок коду, і залишив загальний коментар у секції обговорення. Ви можете побачити, що коментарі до коду також є частиною обговорення.

[[_pr_discussion]]
//.Pull Request discussion page
.Сторінка обговорення Запиту на Пул
//image::images/blink-05-general-comment.png[PR discussion page]
image::images/blink-05-general-comment.png[Сторінка обговорення Запиту на Пул]

//Now the contributor can see what they need to do in order to get their change accepted. Luckily this is also a very simple thing to do. Where over email you may have to re-roll your series and resubmit it to the mailing list, with GitHub you simply commit to the topic branch again and push.
Тепер автори змін можуть бачити, що їм треба зробити, щоб їх зміни прийняли. На щастя це дуже просто зробити. Якби ви використовували пошту для спілкування, вам довелося б переробити ваші зміни та знову відправляти їх до поштового списку (mailing list), а за допомогою GitHub ви можете просто знову зробити коміт до своєї гілки та викласти зміни до GitHub.

//If the contributor does that then the project owner will get notified again and when they visit the page they will see that it's been addressed. In fact, since a line of code changed that had a comment on it, GitHub notices that and collapses the outdated diff.
Якщо автор змін це зробить, то власник проекту знову отримає повідомлення та коли він перейде до сторінки Запиту на Злиття, він побачить, що вона змінена. Насправді, оскільки рядок коду, який був мав коментар, змінився, GitHub це помітив та ховає застарілі зміни.

[[_pr_final]]
//.Pull Request final
.Фінальний Запит на Пул
//image::images/blink-06-final.png[PR final]
image::images/blink-06-final.png[Фінальний Запит на Пул]

//An interesting thing to notice is that if you click on the ``Files Changed'' tab on this Pull Request, you'll get the ``unified'' diff -- that is, the total aggregate difference that would be introduced to your main branch if this topic branch was merged in. In `git diff` terms, it basically automatically shows you `git diff master...<branch>` for the branch this Pull Request is based on. See <<_what_is_introduced>> for more about this type of diff.
Зверніть увагу на те, що якщо ви натиснете на вкладку ``Files Changed'' (змінені файли) цього Запиту на Пул, ви отримаєте ``об'єднану'' різницю -- тобто, повну агреговану різницю, яка буде додана до вашої головної гілки, якщо гілка зі змінами буде до неї злита. У термінах `git diff`, це просто автоматично виконана команда `git diff master...<гілка>`, для гілки, на якої базується цей Запит на Пул. Зверніться до <<_what_is_introduced>> задля докладнішим описом цього типу різниці.

//The other thing you'll notice is that GitHub checks to see if the Pull Request merges cleanly and provides a button to do the merge for you on the server. This button only shows up if you have write access to the repository and a trivial merge is possible. If you click it GitHub will perform a ``non-fast-forward'' merge, meaning that even if the merge *could* be a fast-forward, it will still create a merge commit.
Ще ви помітите, що GitHub сам перевіряє, чи Запит на Пул може бути чисто злитим (без конфліктів) та показує кнопку для злиття прямо на сервері. Ця кнопка відображається тільки якщо у вас є доступ на запис до сховища та просте злиття можливе. Якщо ви на неї натиснете, GitHub зробить злиття ``не-швидко-вперед'' (`non-fast-forward`), тобто навіть якщо злиття могло бути здійснено `швидко-вперед`, все одно буде створений коміт злиття.

//If you would prefer, you can simply pull the branch down and merge it locally. If you merge this branch into the `master` branch and push it to GitHub, the Pull Request will automatically be closed.
Якщо ви бажаєте, ви можете просто отримати гілку та злити її локально. Якщо ви зіллєте цю гілку до гілки `master` та викладете її до GitHub, Запит на Пул автоматично стане закритим.

//This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests are opened on them, a discussion ensues, possibly more work is done on the branch and eventually the request is either closed or merged.
Це базовий процес роботи, який використовує більшість проектів GitHub. Створюєте окрему гілку, одкриваєте Запит на Злиття для неї, виникає обговорення, можливо доводиться допрацювати цю гілку та нарешті запит або закривають, або зливають до проекту.

[NOTE]
//.Not Only Forks
.Не Тільки Форки
====
//It's important to note that you can also open a Pull Request between two branches in the same repository. If you're working on a feature with someone and you both have write access to the project, you can push a topic branch to the repository and open a Pull Request on it to the `master` branch of that same project to initiate the code review and discussion process. No forking necessary.
Важливо зазначити, що ви можете відкрити Запит на Пул між двома гілками одного сховища. Якщо ви працюєте над функціоналом з кимось та ви обидвоє маєте доступ на запис до проекту, ви можете викласти окрему гілку до сховища та відкрити Запит на Пул з неї до гілки `master` того ж самого проекту, щоб розпочати процес перевірки та обговорення коду. Нема потреби створювати форк.
====

//==== Advanced Pull Requests
==== Глибше про Запити на Пул

//Now that we've covered the basics of contributing to a project on GitHub, let's cover a few interesting tips and tricks about Pull Requests so you can be more effective in using them.
Ми розглянули основи того, як робити внесок до проекту на GitHub, розглянемо декілька цікавих порад та хитрощів про Запити на Пул, щоб ви могли користуватись ними ефективніше.

//===== Pull Requests as Patches
===== Запити на Пул як Патчі

//It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions. Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.
Важливо розуміти, що багато проектів не розглядають Запити на Пул як чергу ідеальних патчів, які мають чисто накладатись саме в цьому порядку, як більшість основаних на поштових списках проектів розглядає послідовність патчів. Більшість проектів GitHub розглядають гілки Запитів на Пул як інтерактивну бесіду про запропоновані зміни, їх цікавить тільки результуючі зміни, які додаються до проекту за допомогою злиття.

//This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.
Це важлива відмінність, адже зазвичай зміни пропонуються до того, як код доводять до ідеалу, що є дуже рідкісним у проектах, які використовують поштові списки з послідовностями патчів для співпраці. Це дозволяє обговоренню з супроводжувачем проекту розпочатись раніше, тому вірне рішення досягається спільними зусиллями. Коли код пропонується за допомогою Запита на Пул, та супроводжувачі або спільнота пропонує зміну, послідовність патчів зазвичай не створюється заново, а замість цього зміни просто викладаються як новий коміт до гілки, що просуває обговорення далі без втрати контексту попередньої праці.

//For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.
Наприклад, якщо ви повернетесь та знову подивитесь на <<_pr_final>>, ви можете помітити, що автор змін не робив перебазування свого коміту та не відправляв ще один Запит на Пул. Натомість він додав нові коміти та виклав їх до існуючої гілки. Таким чином, якщо ви повернетесь до цього Запиту на Пул у майбутньому, ви легко знайдете весь контекст всіх прийнятих рішень. При натисканні на кнопку ``Merge'' (злити) на сайті, GitHub навмисно створює коміт злиття з посиланням на Запит на Пул, щоб було легко повернутись та досліджувати обговорення при необхідності.

//===== Keeping up with Upstream
===== Йдемо в Ногу з Оригінальним Проектом

//If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it. GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.
Якщо ваш Запит на Пул стає застарілим, чи не може бути чисто злитим через щось інше, ви забажаєте виправити його, щоб супроводжувач проекту міг легко злити ваші зміни. GitHub перевіряє це та повідомляє вам наприкінці кожного Запиту на Пул чи може він бути злитим без конфліктів.

[[_pr_fail]]
//.Pull Request does not merge cleanly
.Запит на Пул не може бути злитим чисто
//image::images/pr-01-fail.png[PR merge failure]
image::images/pr-01-fail.png[Невдача при злитті Запиту на Пул]

//If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.
Якщо ви бачите щось схоже на <<_pr_fail>>, ви захочете виправити свою гілку щоб зображення стало зеленим та супроводжувачу не довелося виконувати зайвої праці.

//You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.
У вас є два основних варіанти, як це зробити. Ви можете перебазувати вашу гілку поверх цільової гілки (зазвичай це гілка `master` сховища, від якого ви зробили форк), або ви можете злити цільову гілку до вашої гілки.

//Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.
Більшість розробників на GitHub обирають другий варіант через вже зазначені раніше причини. Важлива історія та фінальне злиття, а перебазування дає нам тільки трохи чистішу історію натомість воно *набагато* складніше та в цьому варіанті легше наробити помилок.

//If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.
Якщо ви бажаєте злити цільову гілку до вашої, щоб з’явилася можливість чисто злити ваш Запит на Пул, вам слід додати оригінальне сховище як нове віддалене сховище, зробити з нього фетч, злити головну гілку цього сховища до вашої гілки, виправити будь-які проблеми та нарешті залити це до гілки, на яку відкритий Запит на Пул.

//For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.
Наприклад, припустимо, що в наведеному вище прикладі ``tonychacon'', автор оригінального проекту зробив зміни, які призводять до конфлікту в Запиті на Пул. Розглянемо що треба робити покроково.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

//<1> Add the original repository as a remote named ``upstream''
<1> Додаємо оригінальне сховище як віддалене під ім’ям ``upstream''
//<2> Fetch the newest work from that remote
<2> Отримаємо останні зміни з цього сховища
//<3> Merge the main branch into your topic branch
<3> Зливаємо головну гілку до нашої
//<4> Fix the conflict that occurred
<4> Виправляємо конфлікти
//<5> Push back up to the same topic branch
<5> Заливаємо зміни назад до тієї ж нашої гілки

//Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.
Щойно ви це зробите, Запит на Пул буде автоматично оновлений та знову пройде перевірка на можливість чистого злиття.

[[_pr_merge_fix]]
//.Pull Request now merges cleanly
.Тепер Запит на Злиття можна злити чисто
//image::images/pr-02-merge-fix.png[PR fixed]
image::images/pr-02-merge-fix.png[виправлений Запит На Злиття]

//One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.
Одна з чудових рис Git полягає в тому, що ви можете це робити постійно. Якщо у вас дуже довготривалий проект, ви легко можете зливати з цільової гілки знов і знов та вам доведеться вирішувати тільки ті конфлікти, що виникли після останнього злиття, що дозволяє якось впоратися з процесом.

//If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.
Якщо ви все одно бажаєте перебазувати гілку, щоб її почистити, ви безумовно можете це зробити, проте ми дуже рекомендуємо не заливати зміни насилу (force push) до гілки, для якої ви відкрили Запит на Злиття. Якщо інші люди взяли цю гілку та щось з нею робили, ви наштовхнетеся на багато труднощів, які описані в <<_rebase_peril>>. Замість цього, залийте перебазовану гілку до нової гілки на GitHub та відкривайте абсолютно новий Запит на Пул з посиланням на попередній, та закривайте перший.

//===== References
===== Посилання

//Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.
Можливо ваше наступне питання ``А як мені зробити посилання на попередній Запит на Пул?''. Виявляється є дуже багато методів зробити посилання на інші речі будь-де, де ви можете писати на GitHub.

//Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.
Почнемо з перехресних посилань між Запитом на Пул та Завданням (`Issue`). Усім Запитам на Злиття та Завданням присвоєні номери, що є унікальними в межах проекту. Наприклад, у вас може бути Запит на Пул #3 _та_ Завдання #3. Якщо ви бажаєте послатись на будь-який Запит на Злиття чи Завдання з будь-якого іншого, ви можете просто написати `#<номер>` в будь-якому коментарі чи описі. Ви також можете бути більш детальними, якщо Завдання чи Запит на Пул знаходяться деінде. Пишіть `<ім’я користувача>#<номер>`, якщо ви хочете послатись на Завдання чи Запит на Пул у форку поточного сховища, або `<ім’я користувача>/<назва сховища>#<номер>`, щоб послатись на щось в іншому сховищі.

//Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.
Розглянемо приклад. Припустимо, ми перебазували гілку в попередньому прикладі, створили новий запит на пул для неї, та тепер хочемо послатися на попередній запит на пул з нового. Ми також бажаємо послатись на завдання у форку сховища та на завдання з зовсім іншого проекту. Ми можемо заповнити поле опису як у <<_pr_references>>.

[[_pr_references]]
//.Cross references in a Pull Request.
.Перехресні посилання в Запиті на Пул
//image::images/mentions-01-syntax.png[PR references]
image::images/mentions-01-syntax.png[Посилання в Запиті на Пул]

//When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.
Коли ми відправимо цей запит на пул, ми побачимо, що він відображається як <<_pr_references_render>>.

[[_pr_references_render]]
//.Cross references rendered in a Pull Request.
.Відображення перехресних посилань у Запиті на Пул
//image::images/mentions-02-render.png[PR references rendered]
image::images/mentions-02-render.png[Відображення посилань у Запиті на Пул]

//Notice that the full GitHub URL we put in there was shortened to just the information needed.
Зверніть увагу на те, що повний GitHub URL, що ми ввели, був скорочений саме так, щоб передати всю необхідну інформацію.

//Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<_pr_closed>>.
Тепер якщо Тоні повернеться назад та закриє оригінальний Запит на Пул, ми зможемо це побачити згадку про це в новому, адже GitHub автоматично створить подію зворотнього стеження (`trackback event`) у хронології попереднього Запиту на Пул. Це означає, що будь-хто, хто зайде до цього Запиту на Пул та побачить, що він закритий, легко зможе перейти до сторінки запиту, що його замінив. Посилання буде виглядати приблизно як <<_pr_closed>>.

[[_pr_closed]]
//.Cross references rendered in a Pull Request.
.Відображення перехресного посилання в Запиті на Пул.
//image::images/mentions-03-closed.png[PR closed]
image::images/mentions-03-closed.png[Закритий запит]

//In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.
Крім номерів завдань, ви також можете посилатись на окремий коміт за його SHA-1. Вам доведеться вказати всі 40 символів SHA-1, проте якщо GitHub побачить це в коментарі, він зробить посилання прямо на коміт. Знову ж таки, ви можете посилатись на коміти у форках чи інших сховищах саме так, як ви це робили із завданнями.

==== Markdown

//Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.
Зв’язок з іншими завданнями це тільки мала частина цікавих речей, які ви можете робити майже в будь-якому текстовому полі на GitHub. В описах Завдань та Запитів на Пул, у коментарях, у коментарях до коду та ще багато де, ви можете використовувати так званий ``GitHub різновид Markdown'' (`GitHub Flavored Markdown`). Markdown це простий текст, який відображається з форматуванням.

//See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.
<<_example_markdown>> містить приклад того, як коментарі або текст можуть бути написані та відображені за допомогою Markdown.

[[_example_markdown]]
//.An example of Markdown as written and as rendered.
.Приклад написання та відображення Markdown
//image::images/markdown-01-example.png[Example Markdown]
image::images/markdown-01-example.png[Приклад Markdown]

//===== GitHub Flavored Markdown
===== GitHub Різновид Markdown

//The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.
GitHub різновид Markdown додає деякі речі поза базовим синтаксисом Markdown. Вони можуть бути дуже корисними при створенні докладних описів Запитів на Пул або Завдань або коментарів до них.

//====== Task Lists
====== Списки Завдань

//The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.
Перша дійсно корисна специфічна для GitHub функція Markdown, особливо при використанні з Запитами на Пул, це Список Завдань (`Task List`). Список завдань це список прапорців (`checkbox`) речей, які ви хочете зробити. Зазвичай його додають до Завдання або Запиту на Пул, щоб написати список речей, які мають бути виконані до того, як можна вважати роботу завершеною.

//You can create a task list like this:
Ви можете створити список завдань так:

[source]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

//If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_task_lists>>
Якщо ми додамо це до опису нашого Запиту на Пул або Завдання, воно буде відображатись як <<_task_list>>

[[_task_lists]]
//.Task lists rendered in a Markdown comment.
.Відображення списку завдань Markdown у коментарі.
//image::images/markdown-02-tasks.png[Example Task List]
image::images/markdown-02-tasks.png[Приклад Списку Завдань]

//This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.
Список завдань часто використовується в Запиті на Пул щоб позначити необхідні доопрацювання гілки, до того як Запит на Пул буде готовим до злиття. Дійсно чудове те, що ви можете просто натиснути на прапорець щоб оновити коментар -- вам нема потреби редагувати код Markdown щоб змінювати позначку біля задачі.

//What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.
Більш того, GitHub шукає список задач у ваших Завданнях та Запитах на Пул і відображає їх як метадані на сторінках, що виводять їх список. Наприклад, якщо ви маєте Запит на Пул із задачами та ви дивитесь на оглядову сторінку Запитів на Пул, ви зможете побачити як багато вже зроблено. Це допомагає людям розбити Запити на Пул на дрібніші завдання, та допомагає іншим слідкувати за прогресом гілки. Ви можете подивитись на приклад цього в <<_task_list_progress>>.

[[_task_list_progress]]
//.Task list summary in the Pull Request list.
.Підсумок списку задач у списку Запитів на Пул.
//image::images/markdown-03-task-summary.png[Example Task List]
image::images/markdown-03-task-summary.png[Приклад Списку Задач]

//These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.
Це неймовірно корисно, коли ви відкриваєте Запит на Пул заздалегідь та використовуєте його, щоб слідкувати за своїм прогресом під час написання нової функції.

//====== Code Snippets
====== Уривки коду

//You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.
Ви також можете додавати уривки коду до коментарів. Це особливо корисно, якщо ви хочете показати щось, що ви _могли б_ спробувати до того, як дійсно створювати такий коміт у своїй гілці. Їх також часто використовують щоб додати приклад коду, що не працює, чи коду, який міг би використати цей Запит на Пул.

//To add a snippet of code you have to ``fence'' it in backticks.
Щоб додати уривок коду, вам треба ``огородити'' (`fence`) його зворотними апострофами.

[source]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

//If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.
Якщо додати назву мови, як ми зробили зараз (коли написали 'java'), GitHub також спробує підсвітити синтаксис уривку.

[[_md_code]]
//.Rendered fenced code example.
.Відображення прикладу відгородженого коду.
image::images/markdown-04-fenced-code.png[Відображення відгородженого коду]

//====== Quoting
====== Цитування

//If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.
Якщо ви відповідаєте на маленьку частину довгого коментаря, ви можете вибірково процитувати частину іншого коментаря, якщо поставите на початку кожного рядку знак `>`. Насправді, це настільки поширена та корисна функція, що на клавіатурі для цього є окреме поєднання клавіш. Якщо ви виділите текст у коментарі, на який ви хочете відповісти та натиснете клавішу `r`, відкриється форма коментарю з вже процитованим для вас текстом.

//The quotes look something like this:
Цитування виглядають приблизно так:

[source]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

//Once rendered, the comment will look like <<_md_quote>>.
При відображенні коментар буде виглядати як <<_md_quote>>.

[[_md_quote]]
//.Rendered quoting example.
.Відображення прикладу цитування.
//image::images/markdown-05-quote.png[Rendered quoting]
image::images/markdown-05-quote.png[Відображення цитування]

//====== Emoji
====== Емодзі

//Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.
Нарешті, ви також можете використовувати емодзі у ваших коментарях. Насправді їх використовують доволі широко в коментарях, їх можна побачити в багатьох Завданнях та Запитах на Пул GitHub. У GitHub навіть існує помічник емодзі.

[[_md_emoji_auto]]
//.Emoji autocompleter in action.
.Автодоповнювач Емодзі в дії.
//image::images/markdown-06-emoji-complete.png[Emoji autocompleter]
image::images/markdown-06-emoji-complete.png[Емодзі автодоповнювач]

//Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:
Емодзі мають форму `:<назва>:` будь-де у коментарі. Наприклад, ви можете написати щось таке:

[source]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

//When rendered, it would look something like <<_md_emoji>>.
При відображенні, це виглядатиме приблизно як <<_md_emoji>>.

[[_md_emoji]]
//.Heavy emoji commenting.
.Сповнений емодзі коментар.
image::images/markdown-07-emoji.png[Емодзі]

//Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.
Не те щоб це дуже корисно, проте додає елемент розваги та емоцій до носія, в якому доволі важко передати емоції іншим чином.


[NOTE]
====
//There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:
Насправді доволі багато веб сервісів використовують символи емодзі. Чудова шпаргалка для пошуку емодзі, що виражає потрібну вам емоцію знаходиться за адресою:

http://www.emoji-cheat-sheet.com
====

//====== Images
====== Зображення

//This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.
Технічно це не є частиною Різновиду Markdown GitHUb, проте дуже корисно. На додаток до стандартного додавання посилань на зображення Markdown, що може бути доволі складним через необхідність шукати та вбудовувати URL, GitHub дозволяє вам просто перетягнути зображення до області вводу тексту, щоб вбудувати їх.

[[_md_drag]]
//.Drag and drop images to upload them and auto-embed them.
.Перетягування зображень щоб відвантажити та автоматично вбудувати їх.
//image::images/markdown-08-drag-drop.png[Drag and drop images]
image::images/markdown-08-drag-drop.png[Перетягування зображень]

//If you look back at <<_pr_references>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
Якщо ви знову поглянете на <<_pr_references>>, то побачите маленьку підказку ``Parsed as Markdown'' (оброблено як Markdown) над текстовим полем. Якщо ви натиснете на неї, вам нададуть повну шпаргалку всього, що ви можете робити за допомогою Markdown на GitHub.
