[[_maintaining_gh_project]]
//=== Maintaining a Project
=== Супроводжування Проекту

//Now that we're comfortable contributing to a project, let's look at the other side: creating, maintaining and administering your own project.
Тепер, коли ми знаємо, як робити внески до проектів, поглянемо з іншого боку: створення, супроводжування та адміністрування вашого власного проекту.

//==== Creating a New Repository
==== Створення Нового Сховища

//Let's create a new repository to share our project code with.
Створимо нове сховище, до якого ми додамо код нашого проекту.
//Start by clicking the ``New repository'' button on the right-hand side of the dashboard, or from the `+` button in the top toolbar next to your username as seen in <<_new_repo_dropdown>>.
Спочатку натиснемо кнопку ``New repository'' (нове сховище) праворуч панелі керування, чи за допомогою кнопки `+` у верхній панелі інструментів біля вашого імені користувача, як можна побачити в <<_new_repo_dropdown>>.

//.The ``Your repositories'' area.
.Область ``Your repositories'' (ваші сховища).
//image::images/newrepo.png[The ``Your repositories'' area.]
image::images/newrepo.png[Область ``Your repositories'' (ваші сховища).]

[[_new_repo_dropdown]]
//.The ``New repository'' dropdown.
.``New repository'' (нове сховище) у випадному списку.
//image::images/new-repo.png[The ``new repository'' dropdown.]
image::images/new-repo.png[``New repository'' (нове сховище) у випадному списку.]

//This takes you to the ``new repository'' form:
Тоді ми потрапимо до форми ``нове сховище'':

//.The ``new repository'' form.
.Форма ``нове сховище''.
//image::images/newrepoform.png[The ``new repository'' form.]
image::images/newrepoform.png[Форма ``нове сховище''.]

//All you really have to do here is provide a project name; the rest of the fields are completely optional.
Вам треба лише надати проекту ім’я. Усі інші поля зовсім не обов’язкові.
//For now, just click the ``Create Repository'' button, and boom – you have a new repository on GitHub, named `<user>/<project_name>`.
Зараз просто натисніть на кнопку ``Create Repository'' (створити сховище), і бах – у вас вже є нове сховище на GitHub, під назвою `<ім’я користувача>/<назва проекту>`.

//Since you have no code there yet, GitHub will show you instructions for how create a brand-new Git repository, or connect an existing Git project.
Оскільки у вашому проекті наразі нема коду, GitHub покаже вам інструкції щодо створення абсолютно нового сховища Git, або приєднання існуючого проекту Git.
//We won't belabor this here; if you need a refresher, check out <<_git_basics_chapter>>.
Ми не будемо її тут викладати. Якщо вам необхідно щось з цього пригадати, дивіться <<_git_basics_chapter>>.

//Now that your project is hosted on GitHub, you can give the URL to anyone you want to share your project with.
Тепер у вас є проект на GitHub, ви можете дати URL будь-кому, з ким хочете поділитись своїм проектом.
//Every project on GitHub is accessible over HTTP as `https://github.com/<user>/<project_name>`, and over SSH as `git@github.com:<user>/<project_name>`.
Кожен проект на GitHub є доступним через HTTP за адресою `https://github.com/<user>/<project_name>`, та через SSH за адресою `git@github.com:<user>/<project_name>`.
//Git can fetch from and push to both of these URLs, but they are access-controlled based on the credentials of the user connecting to them.
Git може отримувати та викладати зміни до обох URL, проте вони мають контроль доступу, що базується на запиті ім’я/паролю користувача.

[NOTE]
====
//It is often preferable to share the HTTP based URL for a public project, since the user does not have to have a GitHub account to access it for cloning. Users will have to have an account and an uploaded SSH key to access your project if you give them the SSH URL. The HTTP one is also exactly the same URL they would paste into a browser to view the project there.
Часто більш бажано поширювати HTTP URL публічного проекту, адже тоді користувачу не доведеться мати обліковий запис GitHub щоб зробити клон проекту. Користувачам доведеться мати обліковий запис та відвантажений SSH ключ щоб мати доступ до вашого проекту через SSH. Посилання HTTP ще можна просто вставити до вашого веб-оглядача, щоб побачити там ваш проект.
====

//==== Adding Collaborators
==== Додавання Співпрацівників

//If you're working with other people who you want to give commit access to, you need to add them as ``collaborators''.
Якщо ви працюєте з іншими людьми, та бажаєте надати їм право робити коміти, ви маєте додати їх до ``співпрацівників'' (`collaborators`).
//If Ben, Jeff, and Louise all sign up for accounts on GitHub, and you want to give them push access to your repository, you can add them to your project.
Якщо Бен, Джефф та Луїза усі мають облікові записи на GitHub, та ви бажаєте надати їм доступ на запис до вашого сховища, ви можете додати їх до свого проекту.
//Doing so will give them ``push'' access, which means they have both read and write access to the project and Git repository.
Це надасть їм можливість робити ``push'', тобто вони матимуть доступ і на читання, і на запис до проекту та сховища Git.

//Click the ``Settings'' link at the bottom of the right-hand sidebar.
Натисніть на посилання ``Settings'' (налаштування) знизу бокової панелі праворуч.

//.The repository settings link.
.Посилання на налаштування сховища.
//image::images/reposettingslink.png[The repository settings link.]
image::images/reposettingslink.png[Посилання на налаштування сховища.]

//Then select ``Collaborators'' from the menu on the left-hand side.
Потім виберіть ``Collaborators'' (співпрацівники) з меню ліворуч.
//Then, just type a username into the box, and click ``Add collaborator.''
Потім просто наберіть ім’я в поле, та натисніть ``Add collaborator.'' (додати співпрацівника)
//You can repeat this as many times as you like to grant access to everyone you like.
Ви можете повторювати це скільки завгодно раз, щоб надати доступ усім, кому ви бажаєте.
//If you need to revoke access, just click the ``X'' on the right-hand side of their row.
Якщо вам треба скасувати доступ, просто натисніть на ``X'' з правого боку рядка потрібного користувача.

//.Repository collaborators.
.Співпрацівники сховища.
//image::images/collaborators.png[The repository collaborators box.]
image::images/collaborators.png[Співпрацівники сховища.]

//==== Managing Pull Requests
==== Керування Запитами на Пул (Pull Requests)

//Now that you have a project with some code in it and maybe even a few collaborators who also have push access, let's go over what to do when you get a Pull Request yourself.
Тепер у вас є проект з якимось кодом та можливо навіть декілька співпрацівників з доступом на запис, розгляньмо що робити, якщо хтось направив вам Запит на Пул.

//Pull Requests can either come from a branch in a fork of your repository or they can come from another branch in the same repository. The only difference is that the ones in a fork are often from people where you can't push to their branch and they can't push to yours, whereas with internal Pull Requests generally both parties can access the branch.
Запити на пул можуть надходити або з гілки у форку вашого сховища, або просто з іншої гілки вашого сховища. Єдина різниця, що якщо він з форку, то зазвичай від людей, до гілки яких ви не маєте права викладати зміни та вони не мають права викладати зміни до вашої, а в разі внутрішнього Запиту на Злиття зазвичай обидві сторони мають на це право.

//For these examples, let's assume you are ``tonychacon'' and you've created a new Arduino code project named ``fade''.
Для наступних прикладів, припустімо, що ви ``tonychacon'', та ви створили новий проект Arduino під назвою ``fade''.

[[_email_notifications]]
//===== Email Notifications
===== Повідомлення Електронною Поштою

//Someone comes along and makes a change to your code and sends you a Pull Request. You should get an email notifying you about the new Pull Request and it should look something like <<_email_pr>>.
Хтось приходить, змінює ваш код та відправляє вам Запит на Пул. Вам має надійти лист з повідомленням про новий Запит на Пул, що має виглядати як <<_email_pr>>.

[[_email_pr]]
//.Email notification of a new Pull Request.
.Лист з повідомленням про новий Запит на Пул.
//image::images/maint-01-email.png[Pull Request email notification]
image::images/maint-01-email.png[Лист з повідомленням про новий Запит на Пул]

//There are a few things to notice about this email.
Варто звернути увагу на декілька речей у цьому листі.
//It will give you a small diffstat -- a list of files that have changed in the Pull Request and by how much.
Він включає невелику статистику змін (`diffstat`) - список файлів, що були змінені в Запиті на Пул, та наскільки вони змінились.
//It gives you a link to the Pull Request on GitHub. It also gives you a few URLs that you can use from the command line.
Також у ньому є посилання на сторінку GitHub Запиту на Пул. І ще декілька URL, які ви можете використовувати з командного рядка.

//If you notice the line that says `git pull <url> patch-1`, this is a simple way to merge in a remote branch without having to add a remote.
Якщо ви помітили рядок з текстом `git pull <url> patch-1`, то це простий метод злити зміни з віддаленої гілки без необхідності додавати віддалене сховище.
//We went over this quickly in <<_checking_out_remotes>>.
Ми швидко це розглянули в <<_checking_out_remotes>>.
//If you wish, you can create and switch to a topic branch and then run this command to merge in the Pull Request changes.
Якщо ви бажаєте, то можете створити та перейти до тематичної гілки, а потім виконати цю команду, щоб злити зміни Запиту на Пул.

//The other interesting URLs are the `.diff` and `.patch` URLs, which as you may guess, provide unified diff and patch versions of the Pull Request.
Інші цікаві посилання це `.diff` та `.patch`, які, як ви можете здогадатись, містять Запит на Пул у вигляді об’єднаних змін (unified diff) та патчу.
//You could technically merge in the Pull Request work with something like this:
Ви можете злити Запит на Пул навіть так:

[source,console]
----
$ curl http://github.com/tonychacon/fade/pull/1.patch | git am
----

//===== Collaborating on the Pull Request
===== Співпраця над Запитом на Пул

//As we covered in <<_github_flow>>, you can now have a conversation with the person who opened the Pull Request.
Як ми вже бачили в <<_github_flow>>, ви тепер можете спілкуватись з людиною, яка відкрила Запит на Пул.
//You can comment on specific lines of code, comment on whole commits or comment on the entire Pull Request itself, using GitHub Flavored Markdown everywhere.
Ви можете коментувати окремі рядки коду, коментувати цілі коміти, чи коментувати весь Запит на Пул, за допомогою GitHub різновиду Markdown.

//Every time someone else comments on the Pull Request you will continue to get email notifications so you know there is activity happening.
Щоразу хтось інший коментує Запит на Пул, ви знову будете отримувати лист з повідомленням, отже ви будете знати що відбувається.
//They will each have a link to the Pull Request where the activity is happening and you can also directly respond to the email to comment on the Pull Request thread.
Кожен з листів буде містити посилання на Запит на Пул саме туди, де щось відбулося, а також ви можете відповісти прямо на лист, і коментар у Запиті на Пул буде створено автоматично.

//.Responses to emails are included in the thread.
.Відповідь на лист включається в переписку на GitHub.
image::images/maint-03-email-resp.png[Відповідь листом]

//Once the code is in a place you like and want to merge it in, you can either pull the code down and merge it locally, either with the `git pull <url> <branch>` syntax we saw earlier, or by adding the fork as a remote and fetching and merging.
Щойно код стає вам до вподоби та ви бажаєте його злити, ви можете або зробити пул коду та злити його локально, або використати `git pull <url> <branch>`, як ми бачили раніше, або можете додати форк як віддалене сховище, отримати з нього всі коміти, а потім вже злити зміни.

//If the merge is trivial, you can also just hit the ``Merge'' button on the GitHub site.
Якщо злиття тривіальне, ви також можете просто натиснути на кнопку ``Merge'' (злити) на сайті GitHub.
//This will do a ``non-fast-forward'' merge, creating a merge commit even if a fast-forward merge was possible.
Це зробить злиття ``не-швидко-вперед'' (`non-fast-forward`): створить коміт злиття навіть якщо злиття швидко-вперед можливе.
//This means that no matter what, every time you hit the merge button, a merge commit is created.
Це означає що за будь-яких обставин, щоразу ви натискаєте на кнопку `merge`, буде створено коміт злиття.
//As you can see in <<_merge_button>>, GitHub gives you all of this information if you click the hint link.
Як ви можете побачити на <<_merge_button>>, GitHub надасть вам усю цю інформацію, якщо ви натиснете на посилання вказівки (`hint`).

[[_merge_button]]
//.Merge button and instructions for merging a Pull Request manually.
.Кнопка злиття та інструкції щодо злиття Запиту на Пул вручну.
//image::images/maint-02-merge.png[Merge button]
image::images/maint-02-merge.png[Кнопка злиття]

//If you decide you don't want to merge it, you can also just close the Pull Request and the person who opened it will be notified.
Якщо ви вирішите не зливати Запит, ви також можете просто закрити Запит на Злиття, про що автора запиту буде повідомлено.

[[_pr_refs]]
//===== Pull Request Refs
===== Посилання (Refs) Запитів на Пул

//If you're dealing with a *lot* of Pull Requests and don't want to add a bunch of remotes or do one time pulls every time, there is a neat trick that GitHub allows you to do.
Якщо вам доводиться працювати з *багатьма* Запитами на Злиття, та ви не бажаєте додавати купу віддалених сховищ чи робити по одному пулу на кожен, є один дотепний засіб, який GitHub вам дозволяє використати.
//This is a bit of an advanced trick and we'll go over the details of this a bit more in <<_refspec>>, but it can be pretty useful.
Це дещо складний засіб та ми дещо докладніше розглянемо подробиці того, що відбувається в <<_refspec>>, проте він може бути доволі корисним.

//GitHub actually advertises the Pull Request branches for a repository as sort of pseudo-branches on the server.
Насправді GitHub сприймає гілки Запитів на Злиття для сховища як щось на кшталт псевдо-гілок на сервері.
//By default you don't get them when you clone, but they are there in an obscured way and you can access them pretty easily.
Без додаткових дій ви не отримуєте їх при клонуванні, проте вони є в прихованому вигляді та ви можете доволі легко отримати до них доступ.

//To demonstrate this, we're going to use a low-level command (often referred to as a ``plumbing'' command, which we'll read about more in <<_plumbing_porcelain>>) called `ls-remote`.
Щоб це продемонструвати, ми збираємося використати команду низького рівня (часто їх називають команди ``plumbing'', про що ми прочитаємо більше в <<_plumbing_porcelain>>) під назвою `ls-remote`.
//This command is generally not used in day-to-day Git operations but it's useful to show us what references are present on the server.
Ця команда не потрібна при повсякденному використанні Git, проте вона корисна щоб показати нам, які посилання (`references`) присутні на сервері.

//If we run this command against the ``blink'' repository we were using earlier, we will get a list of all the branches and tags and other references in the repository.
Якщо ми виконаємо цю команду на сховищі ``blink'', яке ми вже раніше використовували, ми отримаємо список усіх гілок та теґів, а також інших посилань у сховищі.

[source,console]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

//Of course, if you're in your repository and you run `git ls-remote origin` or whatever remote you want to check, it will show you something similar to this.
Авжеж, якщо ви у своєму сховищі виконаєте `git ls-remote origin` (замість `origin` може бути будь-яке віддалене сховище), ви отримаєте щось схоже на це.

//If the repository is on GitHub and you have any Pull Requests that have been opened, you'll get these references that are prefixed with `refs/pull/`.
Якщо сховище розміщене на GitHub та у вас є хоч один відкритий Запит на Пул, ви побачите посилання з префіксом `refs/pull/`.
//These are basically branches, but since they're not under `refs/heads/` you don't get them normally when you clone or fetch from the server -- the process of fetching ignores them normally.
Це звичайні гілки, проте оскільки вони не мають префікса `refs/heads/`, ви не отримуєте їх при клонуванні або отриманні змін з серверу -- процес отримання зазвичай повністю їх ігнорує.

//There are two references per Pull Request - the one that ends in `/head` points to exactly the same commit as the last commit in the Pull Request branch.
Для кожного Запиту на Пул є по два посилання: те, що закінчується на `/head` вказує саме на останній коміт до гілки Запиту на Пул.
//So if someone opens a Pull Request in our repository and their branch is named `bug-fix` and it points to commit `a5a775`, then in *our* repository we will not have a `bug-fix` branch (since that's in their fork), but we _will_ have `pull/<pr#>/head` that points to `a5a775`.
Отже, якщо хтось відкриє Запит на Пул до вашого сховища, та їхня гілка називається `bug-fix` та вона вказує на коміт `a5a775`, то у *вашому* сховищі в нас не буде гілки `bug-fix` (адже це не у вашому форку), проте у нас _буде_ `pull/<pr#>/head`, яке вказує на `a5a775`.
//This means that we can pretty easily pull down every Pull Request branch in one go without having to add a bunch of remotes.
Це означає, що ми легко можемо злити кожну гілку Запиту на Пул одразу, і не маємо для цього додавати купу віддалених сховищ.

//Now, you could do something like fetching the reference directly.
Тепер ви можете отримати посилання явно наступним чином:

[source,console]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

//This tells Git, ``Connect to the `origin` remote, and download the ref named `refs/pull/958/head`.''
Ця команда каже Git: ``Приєднайся до віддаленого сховища `origin`, завантаж звідти посилання під назвою `refs/pull/958/head`.''
//Git happily obeys, and downloads everything you need to construct that ref, and puts a pointer to the commit you want under `.git/FETCH_HEAD`.
Git радісно це виконує, та завантажує все, що вам необхідно, щоб відновити це посилання, та записує вказівник до потрібного вам коміту в `.git/FETCH_HEAD`.
//You can follow that up with `git merge FETCH_HEAD` into a branch you want to test it in, but that merge commit message looks a bit weird.
Далі ви можете виконати `git merge FETCH_HEAD`, щоб злити зміни до гілки, в якій ви бажаєте перевірити зміни, проте повідомлення коміту зливання буде виглядати дещо дивно.
//Also, if you're reviewing a *lot* of pull requests, this gets tedious.
Також, якщо ви переглядаєте *багато* запитів на пул, це стає марудним.

//There's also a way to fetch _all_ of the pull requests, and keep them up to date whenever you connect to the remote.
Існує також метод отримати _всі_ запити на пул, та оновлювати їх кожен раз, коли ви з’єднуєтесь з віддаленим сховищем.
//Open up `.git/config` in your favorite editor, and look for the `origin` remote.
Відкрийте `.git/config` у вашому улюбленому редакторі, та знайдіть там віддалене сховище `origin`.
//It should look a bit like this:
Воно має виглядати приблизно так:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

//That line that begins with `fetch =` is a ``refspec.''
Рядок, що починається з `fetch =` є ``специфікацією посилань'' (`refspec`).
//It's a way of mapping names on the remote with names in your local `.git` directory.
Це спосіб відображення імен у віддаленому сховищі в імена у вашій локальній директорії `.git`.
//This particular one tells Git, "the things on the remote that are under `refs/heads` should go in my local repository under `refs/remotes/origin`."
Саме цей рядок з прикладу каже Git: "усе, що на віддаленому сховищі знаходиться під `refs/head` має опинитись у моєму локальному сховищі під `refs/remotes/origin`".
//You can modify this section to add another refspec:
Ви можете відредагувати цю секцію щоб додати іншу специфікацію посилань:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

//That last line tells Git, ``All the refs that look like `refs/pull/123/head` should be stored locally like `refs/remotes/origin/pr/123`.''
Цей останній рядок каже Git: ``Усі посилання, що мають вигляд `refs/pull/123/head`, мають бути збережені локально як `refs/remotes/origin/pr/123`.''
//Now, if you save that file, and do a `git fetch`:
Тепер, якщо ви збережете файл та виконаєте `git fetch`:

[source,console]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

//Now all of the remote pull requests are represented locally with refs that act much like tracking branches; they're read-only, and they update when you do a fetch.
Тепер усі віддалені запити на пул представлені локально посиланнями так само, як і інші віддалені гілки. У них не можна вносити зміни, та вони оновлюються при отриманні змін.
//This makes it super easy to try the code from a pull request locally:
Це робить локальну перевірку коду із запиту на пул супер легкою:

[source,console]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

//The eagle-eyed among you would note the `head` on the end of the remote portion of the refspec.
Найуважніші з вас помітили `head` наприкінці імені віддаленої частини специфікації посилання.
//There's also a `refs/pull/#/merge` ref on the GitHub side, which represents the commit that would result if you push the ``merge'' button on the site.
У сховищі GitHub також є посилання `refs/pull/#/merge`, що вказують на коміт, який ви би отримали при натисканні на кнопку ``merge'' сайту.
//This can allow you to test the merge before even hitting the button.
Це дозволяє вам протестувати зливання до власно натискання на кнопку.

//===== Pull Requests on Pull Requests
===== Запити на Пул до Запитів на Пул

//Not only can you open Pull Requests that target the main or `master` branch, you can actually open a Pull Request targeting any branch in the network.
Ви можете відкривати Запити на Пул не тільки до головної (`master`) гілки, ви насправді можете відкривати Запит на Пул до будь-якої гілки в мережі.
//In fact, you can even target another Pull Request.
Ви дійсно можете навіть відкрити його навіть до іншого Запиту на Пул.

//If you see a Pull Request that is moving in the right direction and you have an idea for a change that depends on it or you're not sure is a good idea, or you just don't have push access to the target branch, you can open a Pull Request directly to it.
Якщо ви побачили Запит на Пул, що рухається у вірному напрямку, та у вас є ідеє зміни, що залежить від цього запиту, або ви невпевнені, що думка гарна, або у вас просто немає прав на запис до гілки запиту, ви можете відкрити Запит на Пул прямо до неї.

//When you go to open a Pull Request, there is a box at the top of the page that specifies which branch you're requesting to pull to and which you're requesting to pull from.
Коли ви відкриваєте Запит на Пул, нагорі сторінки є поле, що задає гілку, до якої ви створюєте запит на пул, та поле, що задає гілку, з якої ви просите взяти зміни.
//If you hit the ``Edit'' button at the right of that box you can change not only the branches but also which fork.
Якщо ви натиснете на кнопку ``Edit'' (редагувати) праворуч від поля, ви зможете вибрати не тільки гілки, а й форк.

[[_pr_targets]]
//.Manually change the Pull Request target fork and branch.
.Вручну змінюємо цільову гілку та форк Запиту на Пул.
image::images/maint-04-target.png[Ціль Запиту на Пул]

//Here you can fairly easily specify to merge your new branch into another Pull Request or another fork of the project.
Як бачите, доволі просто запросити зливання вашої нової гілки до іншого Запиту на Пул або до іншого форку проекту.

//==== Mentions and Notifications
==== Згадки та Повідомлення

//GitHub also has a pretty nice notifications system built in that can come in handy when you have questions or need feedback from specific individuals or teams.
У GitHub також є доволі гарна вбудована система повідомлень, яка може бути доречною, якщо у вас є питання чи вам потрібна допомога від конкретних людей чи команд.

//In any comment you can start typing a `@` character and it will begin to autocomplete with the names and usernames of people who are collaborators or contributors in the project.
У кожному коментарі ви можете набрати символ `@` та він почне автодоповнювання імен та імен користувачів людей, що є співпрацівниками цього проекту, чи просто робили до нього внески.

//.Start typing @ to mention someone.
.Починаємо набирати символ @ щоб когось згадати.
//image::images/maint-05-mentions.png[Mentions]
image::images/maint-05-mentions.png[Згадки]

//You can also mention a user who is not in that dropdown, but often the autocompleter can make it faster.
Ви також можете згадати користувача, якого нема в цьому випадному віконці, проте часто це виходить швидше за допомогою автодоповнювача.

//Once you post a comment with a user mention, that user will be notified.
Щойно ви зробите коментар зі згадкою користувача, він отримає повідомлення.
//This means that this can be a really effective way of pulling people into conversations rather than making them poll.
Тобто це може бути дуже ефективним методом втягнути людей в спілкування, щоб їм не доводилось весь час продивлятись усі дискусії.
//Very often in  Pull Requests on GitHub people will pull in other people on their teams or in their company to review an Issue or Pull Request.
Дуже часто люди на GitHub запрошують інших з їхньої команди чи компанії щоб переглянути Завдання чи Запит на Пул.

//If someone gets mentioned on a Pull Request or Issue, they will be ``subscribed'' to it and will continue getting notifications any time some activity occurs on it.
Якщо когось згадують у Запиті на Пул або Завданні, вони стають ``підписаними'' (subscribed) на них та продовжать отримувати повідомлення щоразу, коли з ними відбувається якась активність.
//You will also be subscribed to something if you opened it, if you're watching the repository or if you comment on something.
Ви також можете бути підписані до чогось, що ви відкрили, якщо ви слідкуєте за сховищем або якщо ви коментували щось.
//If you no longer wish to receive notifications, there is an ``Unsubscribe'' button on the page you can click to stop receiving updates on it.
Якщо ви більше не бажаєте отримувати повідомлення, є кнопка ``Unsubscribe'' (відписатись) на сторінці. Достатньо натиснути на неї, щоб GitHub припинив повідомляти вам про оновлення цієї сторінки.

//.Unsubscribe from an Issue or Pull Request.
.Відписуємось від Завдання чи Запиту на Пул.
//image::images/maint-06-unsubscribe.png[Unsubscribe]
image::images/maint-06-unsubscribe.png[Відписуємось]

//===== The Notifications Page
===== Сторінка Повідомлень

//When we mention ``notifications'' here with respect to GitHub, we mean a specific way that GitHub tries to get in touch with you when events happen and there are a few different ways you can configure them.
Коли ми кажемо ``повідомлення'' (notification) тут щодо GitHub, ми маємо на увазі окремий метод, яким GitHub намагається вам повідомити про якісь події. У вас є декілька різних методів їх налаштувати.
//If you go to the ``Notification center'' tab from the settings page, you can see some of the options you have.
Якщо ви перейдете до вкладки ``Notification center'' (центр повідомлень) зі сторінки налаштувань, ви побачите деякі доступні вам опції.

//.Notification center options.
.Опції центру повідомлень.
//image::images/maint-07-notifications.png[Notification center]
image::images/maint-07-notifications.png[Центр повідомлень]

//The two choices are to get notifications over ``Email'' and over ``Web'' and you can choose either, neither or both for when you actively participate in things and for activity on repositories you are watching.
У вас є дві можливості отримувати повідомлення: через ``Електронну пошту'' або через ``Веб'' та ви можете вибрати один з них, жодного, або обидва для Запитів/Завдань та для активності в сховищах, за якими ви слідкуєте.

//====== Web Notifications
======= Веб Повідомлення 

//Web notifications only exist on GitHub and you can only check them on GitHub.
Веб повідомлення існують тільки на GitHub і ви можете їх перевіряти виключно на GitHub.
//If you have this option selected in your preferences and a notification is triggered for you, you will see a small blue dot over your notifications icon at the top of your screen as seen in <<_not_center>>.
Якщо ця опція ввімкнута у ваших налаштуваннях та вам надійшло повідомлення, ви побачите маленьку синю точку над іконкою повідомлень нагорі вашого екрану, як видно на <<_not_center>>.

[[_not_center]]
//.Notification center.
.Центр повідомлень
//image::images/maint-08-notifications-page.png[Notification center]
image::images/maint-08-notifications-page.png[Центр повідомлень]

//If you click on that, you will see a list of all the items you have been notified about, grouped by project.
Якщо ви на неї натиснете, то побачите список усіх ваших повідомлень, згрупованих по проектам.
//You can filter to the notifications of a specific project by clicking on its name in the left hand sidebar.
Ви можете фільтрувати повідомлення за проектом, якщо натиснете на його назву в панелі ліворуч.
//You can also acknowledge the notification by clicking the checkmark icon next to any notification, or acknowledge _all_ of the notifications in a project by clicking the checkmark at the top of the group.
Також ви можете підтвердити повідомлення, якщо натиснете на пташку (`checkmark`) біля повідомлення, або підтвердити _всі_ повідомлення проекту, якщо натиснете на пташку зверху групи.
//There is also a mute button next to each checkmark that you can click to not receive any further notifications on that item.
Також є кнопка приглушення біля кожної пташки, якщо ви на неї натиснете, ви більше не будете отримувати повідомлень про цю тему.

//All of these tools are very useful for handling large numbers of notifications.
Усі ці інструменти дуже корисні для роботи з великою кількістю повідомлень.
Many GitHub power users will simply turn off email notifications entirely and manage all of their notifications through this screen.
Багато досвідчених користувачів GitHub просто вимикають усі поштові повідомлення та працюють з ними виключно через цю сторінку.

//====== Email Notifications
====== Поштові Повідомлення

//Email notifications are the other way you can handle notifications through GitHub.
Поштові повідомлення -- це інший спосіб обробляти повідомлення GitHub.
//If you have this turned on you will get emails for each notification.
Якщо вони ввімкнені, ви будете отримувати листа щодо кожного повідомлення.
//We saw examples of this in <<_email_notification>> and <<_email_pr>>.
Ми вже бачили їх приклади в <<_email_notification>> та <<_email_pr>>.
//The emails will also be threaded properly, which is nice if you're using a threading email client.
Листи також будуть вірно впорядковані у групи повідомлень, що дуже корисно, якщо ваш поштовий клієнт їх підтримує.

//There is also a fair amount of metadata embedded in the headers of the emails that GitHub sends you, which can be really helpful for setting up custom filters and rules.
Також у листах від GitHub є чимало вбудованих до заголовків метаданих, що дуже допомагає при створенні особистих фільтрів та правил.

//For instance, if we look at the actual email headers sent to Tony in the email shown in <<_email_pr>>, we will see the following among the information sent:
Наприклад, якщо ми подивимось на заголовки листа, що був відправлений до Тоні в <<_email_pr>>, ми побачимо наступне серед відправлених даних:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

//There are a couple of interesting things here.
Тут є декілька цікавих рядків.
//If you want to highlight or re-route emails to this particular project or even Pull Request, the information in `Message-ID` gives you all the data in `<user>/<project>/<type>/<id>` format.
Якщо ви бажаєте обрати або направити всі листи цього проекту, або тільки цього Запиту на Пул, для цього достатньо даних у `Message-ID`: цей заголовок має формат `<користувач>/<проект>/<тип>/<id>`.
//If this were an issue, for example, the `<type>` field would have been ``issues'' rather than ``pull''.
Якби б це було, наприклад, завдання, `<тип>` був би ``issues'' замість ``pull''.

//The `List-Post` and `List-Unsubscribe` fields mean that if you have a mail client that understands those, you can easily post to the list or ``Unsubscribe'' from the thread.
Поля `List-Post` та `List-Unsubscribe` означають, що, якщо ваш поштовий клієнт їх підтримує, ви легко можете написати (`post`) до списку, або відписатись (`unsubscribe`) від розсилки.
//That would be essentially the same as clicking the ``mute'' button on the web version of the notification or ``Unsubscribe'' on the Issue or Pull Request page itself.
Останнє нічим не відрізняється від використання кнопки ``приглушити'' (mute) у веб версії повідомлення та від кнопки ``Unsubscribe'' на сторінці Завдання чи Запиту на Пул.

//It's also worth noting that if you have both email and web notifications enabled and you read the email version of the notification, the web version will be marked as read as well if you have images allowed in your mail client.
Також варто сказати, що якщо у вас ввімкнені поштові та веб повідомлення, та ви прочитаєте поштову версію повідомлення, веб версія також буде позначена прочитаною, якщо ваш поштовий клієнт дозволяє зображення.

//==== Special Files
==== Особливі Файли

//There are a couple of special files that GitHub will notice if they are present in your repository.
Є декілька особливих файлів, що їх присутність у вашому сховищі помічає GitHub.

//==== README
==== README (Прочитай мене)

//The first is the `README` file, which can be of nearly any format that GitHub recognizes as prose.
Першим є файл `README`, який може бути майже будь-якого формату, який GitHub сприймає як текст.
//For example, it could be `README`, `README.md`, `README.asciidoc`, etc.
Наприклад, це може бути `README`, `README.md`, `README.asciidoc` тощо.
//If GitHub sees a README file in your source, it will render it on the landing page of the project.
Якщо GitHub побачить файл README у вашому коді, він відобразить його на головній сторінці вашого проекту.

//Many teams use this file to hold all the relevant project information for someone who might be new to the repository or project.
Багато команд використовують цей файл для зберігання всієї інформації, яка доречна для когось незнайомого зі сховищем або проектом.
//This generally includes things like:
Зазвичай це такі речі як:

//* What the project is for
* Для чого цей проект
//* How to configure and install it
* Як його конфігурувати та інсталювати
//* An example of how to use it or get it running
* Приклад його використання або запуску
//* The license that the project is offered under
* Ліцензія проекту
//* How to contribute to it
* Як зробити внесок до нього

//Since GitHub will render this file, you can embed images or links in it for added ease of understanding.
Оскільки GitHub буде відображати цей файл, ви можете додати до нього зображення або посилання щоб полегшати його читання.

//==== CONTRIBUTING
==== CONTRIBUTING (Як зробити внесок)

//The other special file that GitHub recognizes is the `CONTRIBUTING` file. If you have a file named `CONTRIBUTING` with any file extension, GitHub will show <<_contrib_file>> when anyone starts opening a Pull Request.
Інший особливий файл, на який звертає увагу GitHub, називається `CONTRIBUTING`. Якщо у вас є файл `CONTRIBUTING` з будь-яким розширенням, GitHub покаже <<_contrib_file>> коли хтось почне відкривати Запит на Пул. 

[[_contrib_file]]
//.Opening a Pull Request when a CONTRIBUTING file exists.
.Відкриття Запиту на Пул, якщо існує файл CONTRIBUTING.
//image::images/maint-09-contrib.png[Contributing notice]
image::images/maint-09-contrib.png[Повідомлення про інструкцію по взаємодії з проектом]

//The idea here is that you can specify specific things you want or don't want in a Pull Request sent to your project.
Це зроблено задля того, щоб ви могли вказати що саме ви хочете чи не хочете бачити в Запиті на Пул, який направляють до вашого проекту.
//This way people may actually read the guidelines before opening the Pull Request.
Таким чином люди можуть прочитати ці інструкції до відкриття Запиту на Пул.

//==== Project Administration
==== Адміністрування Проекту

//Generally there are not a lot of administrative things you can do with a single project, but there are a couple of items that might be of interest.
Взагалі-то на GitHub небагато інструментів адміністрування проекту, проте деякі з них можуть бути корисними.

//===== Changing the Default Branch
===== Зміна Типової Гілки

//If you are using a branch other than ``master'' as your default branch that you want people to open Pull Requests on or see by default, you can change that in your repository's settings page under the ``Options'' tab.
Якщо ви використовуєте не гілку ``master'' як головну, тобто гілку, до якої ви бажаєте щоб люди відкривали Запити на Пул, ви можете це змінити на сторінці налаштуваньсвого сховища на вкладці ``Options'' (опції).

[[_default_branch]]
//.Change the default branch for a project.
.Зміна типової гілки проекту.
//image::images/maint-10-default-branch.png[Default branch]
image::images/maint-10-default-branch.png[Типова гілка]

//Simply change the default branch in the dropdown and that will be the default for all major operations from then on, including which branch is checked out by default when someone clones the repository.
Просто змініть типову гілку в випадному віконці та без окремої вказівки всі головні операції будуть відбуватися над нею, зокрема яку гілку буде отримувати сховище при клонуванні.

//===== Transferring a Project
===== Передача Проекту

//If you would like to transfer a project to another user or an organization in GitHub, there is a ``Transfer ownership'' option at the bottom of the same ``Options'' tab of your repository settings page that allows you to do this.
Якщо ви бажаєте передати проект іншому користувачу або організації на GitHub, для цього є опція ``Transfer ownership'' (передача власності) наприкінці тої самої вкладки ``Options'' на сторінці налаштувань вашого сховища.

[[_transfer_project]]
//.Transfer a project to another GitHub user or Organization.
.Передача проекту іншому користувачу або організації GitHub.
//image::images/maint-11-transfer.png[Transfer]
image::images/maint-11-transfer.png[Передача]

//This is helpful if you are abandoning a project and someone wants to take it over, or if your project is getting bigger and want to move it into an organization.
Це корисно якщо ви покидаєте проект та хтось бажає його продовжити, або якщо ваш проект стає більшим і ви бажаєте перемістити його до організації.

//Not only does this move the repository along with all its watchers and stars to another place, it also sets up a redirect from your URL to the new place.
Це не тільки переміщує сховище разом з усіма глядачами (`watcher`) та зірками до іншого місця, а ще й налаштує перенаправлення з вашого URL до нового місця.
//It will also redirect clones and fetches from Git, not just web requests.
Також будуть перенаправлені клонування та отримання змін з Git -- не тільки веб запити.
