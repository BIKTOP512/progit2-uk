=== Libgit2

(((libgit2)))(((C)))
Інша опція для ваших послуг -- використовувати Libgit2.
Libgit2 це вільна від залежностей реалізація Git, яка фокусується на гарному API для використання іншими програмами.
Ви можете знайти його за адресою http://libgit2.github.com[].

Спершу, спробуймо подивитись на те, як виглядає C API.
Ось тур чвалом:

[source,c]
-----
// Відкрити репозиторій
git_repository *repo;
int error = git_repository_open(&repo, "/path/to/repository");

// Отримати коміт, на який вказує HEAD
git_object *head_commit;
error = git_revparse_single(&head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Вивести деякі властивості коміту
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s <%s>\n", author->name, author->email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Прибирання
git_commit_free(commit);
git_repository_free(repo);
-----

Перші декілька рядків відкривають репозиторій Git.
Тип `git_repository` є дескриптором репозиторію з кешем у памʼяті.
Це також найпростіший метод, вам треба лише знати точний шлях до робочої директорії або директорії `.git` репозиторію.
Є також `git_repository_open_ext`, яка включає опції для пошуку, `git_clone` та подібні для створення локального клону віддаленого сховища, та `git_repository_init` для створення цілковито нового сховища.

Другий шматок коду використовує синтаксис rev-parse (докладніше в <<_branch_references>>), щоб отримати коміт, на який врешті-решт вказує HEAD.
Результуючий тип -- вказівник на `git_object`, який відповідає чомусь, що існує в база даних обʼєків Git в репозиторії.
`git_object` насправді є ``батьківським'' типом для декількох різних типів обʼєктів; розташування памʼяті для кожного з типів ``нащадків'' такий саме, як для `git_object`, щоб ви могли безпечно проводити до правильного.
У даному випадку, `git_object_type(commit)` має повернути `GIT_OBJ_COMMIT`, отже його безпечно приводити до вказівнику на `git_commit`.

Наступна частина демонструє нам доступ до властивостей коміту.
Останній рядок використовує тип `git_oid`; це представлення SHA-1 хешу в Libgit2.

З цього прикладу, декілька загальних правил видніються:

* Якщо оголосити вказівник та передати посилання на нього до виклику Libgit2, то цей виклик імовірно поверне цілочисельний код помилки.
  Значення `0` означає успіх; будь-що менше -- помилку.
* Якщо Libgit2 заповнює вказівник для вас, то ви відповідальні за його звільнення.
* Якщо виклик Libgit2 повертає `константний` вказівник, то ви не маєте його звільняти, проте він стане нечинним, коли звільнено обʼєкт, якому він належить.
* Писати на C трохи боляче.

(((Ruby)))
Це останнє означає, що дуже малоймовірно, що ви будете писати на C для використання Libgit2.
На щастя, доступно чимало привʼязувань до окремих мов, що робить роботу зі сховищами Git з вашої окремої мови та середовища доволі легкою.
Погляньмо на вищенаведений приклад, який написано за допомогою привʼязки Libgit2 для Ruby, яка називається Rugged та може бути знайдена за адресою https://github.com/libgit2/rugged[].

[source,ruby]
----
repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} <#{commit.author[:email]}>"
tree = commit.tree
----

Як ви можете бачити, код набагато менш безладний.
По-перше, Rugged використовує винятки; він може генерувати такі речі як `ConfigError` чи `ObjectError`, щоб повідомити про помилкові ситуації.
По-друге, немає ніякого явного звільнення ресурсів, оскільки Ruby має збирання сміття.
Погляньмо на трохи складніший приклад: створення коміту з нуля

[source,ruby]
----
blob_id = repo.write("Blob contents", :blob) # <1>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path => 'newfile.txt', :oid => blob_id) # <2>

sig = {
    :email => "bob@example.com",
    :name => "Bob User",
    :time => Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree => index.write_tree(repo), # <3>
    :author => sig,
    :committer => sig, # <4>
    :message => "Add newfile.txt", # <5>
    :parents => repo.empty? ? [] : [ repo.head.target ].compact, # <6>
    :update_ref => 'HEAD', # <7>
)
commit = repo.lookup(commit_id) # <8>
----

<1> Створити новий блоб, який містить вміст нового файлу.
<2> Наповнити індекс верхівкою дерева коміту, та додати новий файл під шляхом `newfle.txt`.
<3> Це створює нове дерево в ODB, та використовує його для нового коміту.
<4> Ми використовуємо однаковий підпис як для автора, так і для автора коміту.
<5> Повідомлення коміту.
<6> Під час створення коміту, ви маєте задати батьків нового коміту.
    Це використовує верхівку HEAD для єдиного батька.
<7> Rugged (та Libgit2) може додатково оновити посилання під час створення коміту.
<8> Повертається значення SHA-1 хешу нового обʼєкту коміту, яке ви можете потім використати для отримання обʼєкту `Commit`.

Код Ruby гарний та чистий, проте оскільки Libgit2 робить усе можливе для оптимізації, цей код буде також працювати швидко.
Якщо ви не прихильник Ruby, ми ознайомимось з іншими привʼязками в <<_libgit2_bindings>>.


==== Заглиблений функціонал

Libgit2 має декілька можливостей, які є поза межами ядра Git.
Одним прикладом є можливість використання додатків: Libgit2 дозволяє вам надавати власні обробники (backend) для декількох типів операцій, щоб ви могли зберігати речі у інший спосіб, ніж типовий Git.
Libgit2 також дозволяє власні обробники для, серед іншого, конфігурації, збереження посилань та бази даних обʼєктів.

Погляньмо, як це працює.
Код нижче позичено з набору прикладів обробників, які надає команда Libgit2 (який можна знайти за адресою https://github.com/libgit2/libgit2-backends[]).
Ось як налаштувати власний обробник для бази даних обʼєктів:

[source,c]
----
git_odb *odb;
int error = git_odb_new(&odb); // <1>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&my_backend, /*…*/); // <2>

error = git_odb_add_backend(odb, my_backend, 1); // <3>

git_repository *repo;
error = git_repository_open(&repo, "some-path");
error = git_repository_set_odb(odb); // <4>
----

_(Note that errors are captured, but not handled. We hope your code is better than ours.)_

<1> Ініціалізація порожньої бази даних обʼєктів (ODB - object database), клієнтської частини, яка буде діяти як контейнер для обробників, які у свою чергу виконуватимуть справжню роботу.
<2> Ініціалізація власного обробника ODB.
<3> Додавання обробника до клієнтської частини.
<4> Відкривання сховища, та надання йому нашого ODB для пошуку обʼєктів.

Проте що таке цей `git_odb_backend_mine`?
Ну, це конструктор для вашої власної імплементації ODB, і ви можете зробити тут усе, що забажаєте, доки ви заповните структуру `git_odb_backend` правильно.
Ось як вона _може_ виглядати:

[source,c]
----
typedef struct {
    git_odb_backend parent;

    // Деякі інші речі
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend->custom_context = …;

    backend->parent.read = &my_backend__read;
    backend->parent.read_prefix = &my_backend__read_prefix;
    backend->parent.read_header = &my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}
----

The subtlest constraint here is that `my_backend_struct`'s first member must be a `git_odb_backend` structure; this ensures that the memory layout is what the Libgit2 code expects it to be.
The rest of it is arbitrary; this structure can be as large or small as you need it to be.

The initialization function allocates some memory for the structure, sets up the custom context, and then fills in the members of the `parent` structure that it supports.
Take a look at the `include/git2/sys/odb_backend.h` file in the Libgit2 source for a complete set of call signatures; your particular use case will help determine which of these you'll want to support.

[[_libgit2_bindings]]
==== Other Bindings

Libgit2 has bindings for many languages.
Here we show a small example using a few of the more complete bindings packages as of this writing; libraries exist for many other languages, including C++, Go, Node.js, Erlang, and the JVM, all in various stages of maturity.
The official collection of bindings can be found by browsing the repositories at https://github.com/libgit2[].
The code we'll write will return the commit message from the commit eventually pointed to by HEAD (sort of like `git log -1`).


===== LibGit2Sharp

(((.NET)))(((C#)))(((Mono)))
If you're writing a .NET or Mono application, LibGit2Sharp (https://github.com/libgit2/libgit2sharp[]) is what you're looking for.
The bindings are written in C#, and great care has been taken to wrap the raw Libgit2 calls with native-feeling CLR APIs.
Here's what our example program looks like:

[source,csharp]
-----
new Repository(@"C:\path\to\repo").Head.Tip.Message;
-----

For desktop Windows applications, there's even a NuGet package that will help you get started quickly.

===== objective-git

(((Apple)))(((Objective-C)))(((Cocoa)))
If your application is running on an Apple platform, you're likely using Objective-C as your implementation language.
Objective-Git (https://github.com/libgit2/objective-git[]) is the name of the Libgit2 bindings for that environment.
The example program looks like this:

[source,objc]
-----
GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];
-----

Objective-git is fully interoperable with Swift, so don't fear if you've left Objective-C behind.


===== pygit2

(((Python)))
The bindings for Libgit2 in Python are called Pygit2, and can be found at http://www.pygit2.org/[].
Our example program:

[source,python]
----
pygit2.Repository("/path/to/repo") # open repository
    .head                          # get the current branch
    .peel(pygit2.Commit)           # walk down to the commit
    .message                       # read the message
----


==== Further Reading

Of course, a full treatment of Libgit2's capabilities is outside the scope of this book.
If you want more information on Libgit2 itself, there's API documentation at https://libgit2.github.com/libgit2[], and a set of guides at https://libgit2.github.com/docs[].
For the other bindings, check the bundled README and tests; there are often small tutorials and pointers to further reading there.
