[appendix]
== Команди Git

Упродовж книги ми використовували десятки команд Git та дуже намагались представляти їх з приміткою, додавати нові команди до оповідання повільно. Втім, це призводить до того, що приклади використання команд дещо розкидані по всій книзі.

У цьому додатку, ми переглянемо всі команди Git, до яких зверталися протягом книги, грубо згуртовані за призначенням. Ми поговоримо про те, що кожна команда робить дуже загально та вкажемо, де в книзі ви можете знайти її використання.


=== Налаштування та конфігурація

Існує дві команди, які були дуже вживані, від перших викликів Git до повсякденного долаштування та : команди `config` та `help`.

==== git config

Git має типовий спосіб, як робити сотні речей. Для більшості з них, ви можете сказати Git працювати типово інакше, або встановити свої вподобання. Це включає все від надання Git свого імʼя до визначення кольорів у терміналі чи який редактор використовувати. Існує декілька файлів, які ця команда читає та пише, щоб ви могли встановлювати значення як глобально, так і для окремих сховищ.

Команда `git config` використовується майже в кожному розділі цієї книги.

У <<_first_time>> ми використовували її щоб задати своє імʼя, поштову скриньку та редактор, навіть перед початком використання Git.

У <<_git_aliases>> ми показали, як ви можете використовувати її для створення скорочених команд, які розкриваються в довгі послідовності опцій, щоб вам не доводилося набирати їх щоразу.

У <<_rebasing>> ми використали її, щоб зробити `--rebase` типовим, коли ви виконуєте `git pull`.

У <<_credential_caching>> ми використали її, щоб налаштувати типове збереження ваших паролів HTTP.

У <<_keyword_expansion>> ми показали, як налаштувати фільтри smudge (забруднити) та clean (очистити) для вмісту, що приходить з і йде до Git.

Нарешті, фактично весь <<_git_config>> присвячено цій команді.

==== git help

Команда `git help` призначена для відображення документації, що постачається разом з Git для кожної команди. Хоча ми даємо деякий огляд більшості з більш поширених команд у цьому додатку, для повного списку всіх можливих опцій кожної команди, ви завжди можете виконати `git help <команда>`.

Ми представили команду `git help` у <<_git_help>> та показали, як скористатись нею, щоб знайти більше інформації про `git shell` у <<_setting_up_server>>.


=== Отримання та створення проектів

Існує два способи отримати сховище Git. Перший -- скопіювати його з існуючого проекту з мережі чи деінде, а другий -- створити нове в існуючій директорії.

==== git init

Щоб взяти директорію та перетворити її на новий репозиторій Git, щоб ви могли почати керувати її версіями, ви можете просто виконати `git init`.

Ми вперше представляємо її в <<_getting_a_repo>>, де ми демонструємо створення цілковито нового сховища для початку роботи з ним.

Ми коротко розповідаємо про те, як ви можете змінити назву типової гілки ``master'' у <<_remote_branches>>.

Ми використовуємо цю команду для створення порожнього чистого (bare) сховища для сервера в <<_bare_repo>>.

Нарешті, ми розглядаємо деякі подробиці того, що насправді коїться за кулісами в <<_plumbing_porcelain>>.

==== git clone

Команда `git clone` насправді є чимось на кшталт обгортки над декількома іншими командами. Вона створює нову директорію, переходить до неї та виконує `git init`, щоб зробити порожнє сховище Git, додає віддалене сховище (`git remote add`) з URL, яке ви надали їй (типово називає його `origin`), виконує `git fetch` з нього, а потім отримує останній коміт до вашої робочої директорії за допомогою `git checkout`.

Команда `git clone` використовується в десятках місць у цій книзі, проте ми опишемо з них лише декілька цікавих.

Вона представлена та розглянута в <<_git_cloning>>, де ми проходимо декілька прикладів.

У <<_git_on_the_server>> ми дивимось на використання опції `--bare` для створення копії репозиторію Git без робочої директорії.

У <<_bundling>> ми використовуємо її для розпакування запакованого (bundled) сховища Git.

Нарешті, у <<_cloning_submodules>> ми дізнаємося про опцію `--recursive`, щоб зробити клонування сховища з підмодулями трохи простішим.

Хоча її використано в багатьох інших місцях книги, це ті з них, в яких є щось особливо або де вона використовується в трохи інший спосіб.


=== Базове збереження відбитків

Для базового процесу роботи індексування вмісту та збереження його в комітах вашої історії, є лише декілька базових команд.

==== git add

Команда `git add` додає вміст з робочої директорії до індексу (чи області додавання) для наступного коміту. Коли виконується команда `git commit`, типово вона дивиться лише на індекс, отже `git add` використовується для підготовки того, яким саме ви бажаєте зробити наступний відбиток коміту.

Ця команда неймовірно важлива в Git і згадується та використовується десятки разів у цій книзі. Ми швидко розглянемо деякі особливі використання, які можна знайти.

Спершу ми представляємо та пояснюємо докладно `git add` у <<_tracking_files>>.

Ми згадуємо, як використати її для розвʼязання конфліктів у <<_basic_merge_conflicts>>.

Ми розглядаємо її використання для інтерактивного додавання лише окремих частин редагованих файлів у <<_interactive_staging>>.

Нарешті, ми емулюємо її на низькому рівні в <<_tree_objects>>, щоб ви могли уявити, що виконується за кулісами.

==== git status

Команда `git status` покаже вам різні стани файлів у вашій робочій директорії та індексі. Які файли змінені, проте не в індексі, а які індексовані, проте досі не збережені в коміті. У звичайній формі, вона також покаже вам деякі базові підказки щодо переміщення файлів між цими станами.

Спочатку и розглядаємо `status` у <<_checking_status>>, як базову, як і спрощену форми. Хоча ми використовуємо її впродовж книги, дійсно все, що ви можете робити за допомогою команди `git status` розглянуто там.

==== git diff

Команда `git diff` використовується, коли ви бажаєте побачити різницю між якимись двома деревами. Це може бути різниця між вашим робочим середовищем та індексом (просто `git diff`), між вашим індексом та останнім комітом (`git diff --staged`), або між двома комітами (`git diff master branchB`).

Ми вперше бачимо базове використання `git diff` у <<_git_diff_staged>>, де ми показуємо, як дізнатись, які зміни індексовані, а які ще ні.

Ми використовуємо її, щоб побачити можливі проблеми з пробільними символами перед створенням коміту за допомогою опції `--check` у <<_commit_guidelines>>.

Ми бачимо, як перевірити різницю між гілками ефективніше за допомогою синтаксису `git diff A...B` у <<_what_is_introduced>>.

Ми дізнаємось, як ігнорувати різницю в пробільних символах за допомогою `-b` та як порівняти стани конфліктних файлів за допомогою `--theirs`, `--ours` та `--base` у <<_advanced_merging>>.

Нарешті, ми використовуємо її для ефективного порівняння змін у підмодулях за допомогою `--submodule` у <<_starting_submodules>>.


==== git difftool

Команда `git difftool` просто запускає зовнішній інструмент, щоб показати вам різницю між двома гілками у випадку, якщо ви бажаєте використати щось інше, ніж вбудовану команду `git diff`.

Ми лише коротко згадуємо про це в <<_git_diff_staged>>.

==== git commit

Команда `git commit` бере вміст всіх файлів, які ви індексували командою `git add`, та записує новий сталий відбиток до бази даних, а потім пересуває вказівник поточної гілки до нього.

Спочатку ми розглядаємо базове створення комітів у <<_committing_changes>>. Там ми також демонструємо використання опції `-a` для пропуску кроку `git add` у щоденних процесах роботи, та як використати опцію `-m`, щоб передати повідомлення коміту з командного рядку замість запуску редактора.

У <<_undoing>> ми розглядаємо використання опції `--amend` для переробки останнього коміту.

У <<_git_branches_overview>>, ми набагато детальніше розглядаємо, що робить `git commit` та чому він це робить таким чином.

Ми бачили, як підписувати коміти криптографічно за допомогою опції `-S` у <<_signing_commits>>.

Нарешті, ми поглянули на те, що робить команда `git commit` у фоні та як вона насправді імплементована в <<_git_commit_objects>>.

==== git reset

Команда `git reset` переважно використовується для скасування речей, як ви напевно можете здогадатись через дієслово. Вона переміщує вказівник `HEAD`, а також може змінити індекс (область додавання) та може змінити робочу директорію, якщо ви використаєте `--hard`. Ця остання опція робить можливим втрату вашої праці через цю команду, якщо використати її неправильно, отже переконайтесь, що ви розумієте її перед використанням.

Ми спочатку розглядаємо найпростіше використання `git reset` в <<_unstaging>>, де ми використовуємо її для деіндексації файлу, на якому ми були виконали `git add`.

Ми потім розглядаємо її доволі детально в <<_git_reset>>, яка повністю присвячена поясненню цієї команди.

Ми використовуємо `git reset --hard` для скасування злиття у <<_abort_merge>>, де ми також використовуємо `git merge --abort`, яка є трохи обгорткою для команди `git reset`.

==== git rm

Команда `git rm` використовується для вилучення файлів з індексу та робочої директорії Git. Вона схожа на `git add` в тому, що індексує вилучення файлу для наступного коміту.

Ми розглядаємо команду `git rm` дещо детально в <<_removing_files>>, включно з рекурсивним вилученням файлів та вилученням лише з індексу, проте залишаючи їх у робочій директорії за допомогою `--cached`.

Єдине інше відмінне використання `git rm` у книзі є в <<_removing_objects>>, де ми стисло пояснюємо `--ignore-unmatch` при виконанні `git filter-branch`, яке просто змушує не вважати помилкою відсутність файлу під час спроби його вилучити. Це може бути корисним для написання скриптів.

==== git mv

Команда `git mv` є маленькою зручною командою, яка переміщує файл, виконує `git add` для нового файлу та `git rm` для старого.

Ми лише мимохідь згадуємо цю команду в <<_git_mv>>.

==== git clean

Команда `git clean` використовується для вилучення небажаних файлів з вашої робочої директорії. Це може включати вилучення тимчасових результатів зборки, чи файлів конфлікту злиття.

Ми розглядаємо багато опцій та випадків, в яких ви можете використати команду clean у <<_git_clean>>.

=== Branching and Merging

There are just a handful of commands that implement most of the branching and merging functionality in Git.

==== git branch

The `git branch` command is actually something of a branch management tool. It can list the branches you have, create a new branch, delete branches and rename branches.

Most of <<_git_branching>> is dedicated to the `branch` command and it's used throughout the entire chapter. We first introduce it in <<_create_new_branch>> and we go through most of its other features (listing and deleting) in <<_branch_management>>.

In <<_tracking_branches>> we use the `git branch -u` option to set up a tracking branch.

Finally, we go through some of what it does in the background in <<_git_refs>>.

==== git checkout

The `git checkout` command is used to switch branches and  check content out into your working directory.

We first encounter the command in <<_switching_branches>> along with the `git branch` command.

We see how to use it to start tracking branches with the `--track` flag in <<_tracking_branches>>.

We use it to reintroduce file conflicts with `--conflict=diff3` in <<_checking_out_conflicts>>.

We go into closer detail on its relationship with `git reset` in <<_git_reset>>.

Finally, we go into some implementation detail in <<_the_head>>.

==== git merge

The `git merge` tool is used to merge one or more branches  into the branch you have checked out. It will then advance the current branch to the result of the merge.

The `git merge` command was first introduced in <<_basic_branching>>. Though it is used in various places in the book, there are very few variations of the `merge` command -- generally just `git merge <branch>` with the name of the single branch you want to merge in.

We covered how to do a squashed merge (where Git merges the work but pretends like it's just a new commit without recording the history of the branch you're merging in) at the very end of <<_public_project>>.

We went over a lot about the merge process and command, including the `-Xignore-space-change` command and the `--abort` flag to abort a problem merge in <<_advanced_merging>>.

We learned how to verify signatures before merging if your project is using GPG signing in <<_signing_commits>>.

Finally, we learned about Subtree merging in <<_subtree_merge>>.

==== git mergetool

The `git mergetool` command simply launches an external merge helper in case you have issues with a merge in Git.

We mention it quickly in <<_basic_merge_conflicts>> and go into detail on how to implement your own external merge tool in <<_external_merge_tools>>.

==== git log

The `git log` command is used to show the reachable recorded history of a project from the most recent commit snapshot backwards. By default it will only show the history of the branch you're currently on, but can be given different or even multiple heads or branches from which to traverse. It is also often used to show differences between two or more branches at the commit level.

This command is used in nearly every chapter of the book to demonstrate the history of a project.

We introduce the command and cover it in some depth in <<_viewing_history>>. There we look at the `-p` and `--stat` option to get an idea of what was introduced in each commit and the `--pretty` and `--oneline` options to view the history more concisely, along with some simple date and author filtering options.

In <<_create_new_branch>> we use it with the `--decorate` option to easily visualize where our branch pointers are located and we also use the `--graph` option to see what divergent histories look like.

In <<_private_team>> and <<_commit_ranges>> we cover the `branchA..branchB` syntax to use the `git log` command to see what commits are unique to a branch relative to another branch. In <<_commit_ranges>> we go through this fairly extensively.

In <<_merge_log>> and <<_triple_dot>> we cover using the `branchA...branchB` format and the `--left-right` syntax to see what is in one branch or the other but not in both. In <<_merge_log>> we also look at how to use the `--merge` option to help with merge conflict debugging as well as using the `--cc` option to look at merge commit conflicts in your history.

In <<_git_reflog>> we use the `-g` option to view the Git reflog through this tool instead of doing branch traversal.

In <<_searching>> we look at using the `-S` and `-L` options to do fairly sophisticated searches for something that happened historically in the code such as seeing the history of a function.

In <<_signing_commits>> we see how to use `--show-signature` to add a validation string to each commit in the `git log` output based on if it was validly signed or not.

==== git stash

The `git stash` command is used to temporarily store uncommitted work in order to clean out your working directory without having to commit unfinished work on a branch.

This is basically entirely covered in <<_git_stashing>>.

==== git tag

The `git tag` command is used to give a permanent bookmark to a specific point in the code history. Generally this is used for things like releases.

This command is introduced and covered in detail in <<_git_tagging>> and we use it in practice in <<_tagging_releases>>.

We also cover how to create a GPG signed tag with the `-s` flag and verify one with the `-v` flag in <<_signing>>.


=== Sharing and Updating Projects

There are not very many commands in Git that access the network, nearly all of the commands operate on the local database. When you are ready to share your work or pull changes from elsewhere, there are a handful of commands that deal with remote repositories.

==== git fetch

The `git fetch` command communicates with a remote repository and fetches down all the information that is in that repository that is not in your current one and stores it in your local database.

We first look at this command in <<_fetching_and_pulling>> and we continue to see examples of it use in <<_remote_branches>>.

We also use it in several of the examples in <<_contributing_project>>.

We use it to fetch a single specific reference that is outside of the default space in <<_pr_refs>> and we see how to fetch from a bundle in <<_bundling>>.

We set up highly custom refspecs in order to make `git fetch` do something a little different than the default in <<_refspec>>.

==== git pull

The `git pull` command is basically a combination of the `git fetch` and `git merge` commands, where Git will fetch from the remote you specify and then immediately try to merge it into the branch you're on.

We introduce it quickly in <<_fetching_and_pulling>> and show how to see what it will merge if you run it in <<_inspecting_remote>>.

We also see how to use it to help with rebasing difficulties in <<_rebase_rebase>>.

We show how to use it with a URL to pull in changes in a one-off fashion in <<_checking_out_remotes>>.

Finally, we very quickly mention that you can use the `--verify-signatures` option to it in order to verify that commits you are pulling have been GPG signed in <<_signing_commits>>.

==== git push

The `git push` command is used to communicate with another repository, calculate what your local database has that the remote one does not, and then pushes the difference into the other repository. It requires write access to the other repository and so normally is authenticated somehow.

We first look at the `git push` command in <<_pushing_remotes>>. Here we cover the basics of pushing a branch to a remote repository. In <<_pushing_branches>> we go a little deeper into pushing specific branches and in <<_tracking_branches>> we see how to set up tracking branches to automatically push to. In <<_delete_branches>> we use the `--delete` flag to delete a branch on the server with `git push`.

Throughout <<_contributing_project>> we see several examples of using `git push` to share work on branches through multiple remotes.

We see how to use it to share tags that you have made with the `--tags` option in <<_sharing_tags>>.

In <<_publishing_submodules>> we use the `--recurse-submodules` option to check that all of our submodules work has been published before pushing the superproject, which can be really helpful when using submodules.

In <<_other_client_hooks>> we talk briefly about the `pre-push` hook, which is a script we can setup to run before a push completes to verify that it should be allowed to push.

Finally, in <<_pushing_refspecs>> we look at pushing with a full refspec instead of the general shortcuts that are normally used. This can help you be very specific about what work you wish to share.

==== git remote

The `git remote` command is a management tool for your record of remote repositories. It allows you to save long URLs as short handles, such as ``origin'' so you don't have to type them out all the time. You can have several of these and the `git remote` command is used to add, change and delete them.

This command is covered in detail in <<_remote_repos>>, including listing, adding, removing and renaming them.

It is used in nearly every subsequent chapter in the book too, but always in the standard `git remote add <name> <url>` format.

==== git archive

The `git archive` command is used to create an archive file of a specific snapshot of the project.

We use `git archive` to create a tarball of a project for sharing in <<_preparing_release>>.

==== git submodule

The `git submodule` command is used to manage external repositories within a normal repositories. This could be for libraries or other types of shared resources. The `submodule` command has several sub-commands (`add`, `update`, `sync`, etc) for managing these resources.

This command is only mentioned and entirely covered in <<_git_submodules>>.

=== Inspection and Comparison

==== git show

The `git show` command can show a Git object in a simple and human readable way. Normally you would use this to show the information about a tag or a commit.

We first use it to show annotated tag information in <<_annotated_tags>>.

Later we use it quite a bit in <<_revision_selection>> to show the commits that our various revision selections resolve to.

One of the more interesting things we do with `git show` is in <<_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

==== git shortlog

The `git shortlog` command is used to summarize the output of `git log`. It will take many of the same options that the `git log` command will but instead of listing out all of the commits it will present a summary of the commits grouped by author.

We showed how to use it to create a nice changelog in <<_the_shortlog>>.

==== git describe

The `git describe` command is used to take anything that resolves to a commit and produces a string that is somewhat human-readable and will not change. It's a way to get a description of a commit that is as unambiguous as a commit SHA-1 but more understandable.

We use `git describe` in <<_build_number>> and <<_preparing_release>> to get a string to name our release file after.


=== Debugging

Git has a couple of commands that are used to help debug an issue in your code. This ranges from figuring out where something was introduced to figuring out who introduced it.

==== git bisect

The `git bisect` tool is an incredibly helpful debugging tool used to find which specific commit was the first one to introduce a bug or problem by doing an automatic binary search.

It is fully covered in <<_binary_search>> and is only mentioned in that section.

==== git blame

The `git blame` command annotates the lines of any file with which commit was the last one to introduce a change to each line of the file and what person authored that commit. This is helpful in order to find the person to ask for more information about a specific section of your code.

It is covered in <<_file_annotation>> and is only mentioned in that section.

==== git grep

The `git grep` command can help you find any string or regular expression in any of the files in your source code, even older versions of your project.

It is covered in <<_git_grep>> and is only mentioned in that section.

=== Patching

A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches. These commands help you manage your branches in this manner.

==== git cherry-pick

The `git cherry-pick` command is used to take the change introduced in a single Git commit and try to re-introduce it as a new commit on the branch you're currently on. This can be useful to only take one or two commits from a branch individually rather than merging in the branch which takes all the changes.

Cherry picking is described and demonstrated in <<_rebase_cherry_pick>>.

==== git rebase

The `git rebase` command is basically an automated `cherry-pick`. It determines a series of commits and then cherry-picks them one by one in the same order somewhere else.

Rebasing is covered in detail in <<_rebasing>>, including covering the collaborative issues involved with rebasing branches that are already public.

We use it in practice during an example of splitting your history into two separate repositories in <<_replace>>, using the `--onto` flag as well.

We go through running into a merge conflict during rebasing in <<_rerere>>.

We also use it in an interactive scripting mode with the `-i` option in <<_changing_multiple>>.

==== git revert

The `git revert` command is essentially a reverse `git cherry-pick`. It creates a new commit that applies the exact opposite of the change introduced in the commit you're targeting, essentially undoing or reverting it.

We use this in <<_reverse_commit>> to undo a merge commit.

=== Email

Many Git projects, including Git itself, are entirely maintained over mailing lists. Git has a number of tools built into it that help make this process easier, from generating patches you can easily email to applying those patches from an email box.

==== git apply

The `git apply` command applies a patch created with the `git diff` or even GNU diff command. It is similar to what the `patch` command might do with a few small differences.

We demonstrate using it and the circumstances in which you might do so in <<_patches_from_email>>.

==== git am

The `git am` command is used to apply patches from an email inbox, specifically one that is mbox formatted. This is useful for receiving patches over email and applying them to your project easily.

We covered usage and workflow around `git am` in <<_git_am>> including using the `--resolved`, `-i` and `-3` options.

There are also a number of hooks you can use to help with the workflow around `git am` and they are all covered in <<_email_hooks>>.

We also use it to apply patch formatted GitHub Pull Request changes in <<_email_notifications>>.

==== git format-patch

The `git format-patch` command is used to generate a series of patches in mbox format that you can use to send to a mailing list properly formatted.

We go through an example of contributing to a project using the `git format-patch` tool in <<_project_over_email>>.

==== git imap-send

The `git imap-send` command uploads a mailbox generated with `git format-patch` into an IMAP drafts folder.

We go through an example of contributing to a project by sending patches with the `git imap-send` tool in <<_project_over_email>>.

==== git send-email

The `git send-email` command is used to send patches that are generated with `git format-patch` over email.

We go through an example of contributing to a project by sending patches with the `git send-email` tool in <<_project_over_email>>.

==== git request-pull

The `git request-pull` command is simply used to generate an example message body to email to someone. If you have a branch on a public server and want to let someone know how to integrate those changes without sending the patches over email, you can run this command and send the output to the person you want to pull the changes in.

We demonstrate how to use `git request-pull` to generate a pull message in <<_public_project>>.

=== External Systems

Git comes with a few commands to integrate with other version control systems.

==== git svn

The `git svn` command is used to communicate with the Subversion version control system as a client. This means you can use Git to checkout from and commit to a Subversion server.

This command is covered in depth in <<_git_svn>>.

==== git fast-import

For other version control systems or importing from nearly any format, you can use `git fast-import` to quickly map the other format to something Git can easily record.

This command is covered in depth in <<_custom_importer>>.

=== Administration

If you're administering a Git repository or need to fix something in a big way, Git provides a number of administrative commands to help you out.

==== git gc

The `git gc` command runs ``garbage collection'' on your repository, removing unnecessary files in your database and packing up the remaining files into a more efficient format.

This command normally runs in the background for you, though you can manually run it if you wish. We go over some examples of this in <<_git_gc>>.

==== git fsck

The `git fsck` command is used to check the internal database for problems or inconsistencies.

We only quickly use this once in <<_data_recovery>> to search for dangling objects.

==== git reflog

The `git reflog` command goes through a log of where all the heads of your branches have been as you work to find commits you may have lost through rewriting histories.

We cover this command mainly in <<_git_reflog>>, where we show normal usage to and how to use `git log -g` to view the same information with `git log` output.

We also go through a practical example of recovering such a lost branch in <<_data_recovery>>.

==== git filter-branch

The `git filter-branch` command is used to rewrite loads of commits according to certain patterns, like removing a file everywhere or filtering the entire repository down to a single subdirectory for extracting a project.

In <<_removing_file_every_commit>> we explain the command and explore several different options such as `--commit-filter`, `--subdirectory-filter` and `--tree-filter`.

In <<_git_p4>> and <<_git_tfs>> we use it to fix up imported external repositories.


=== Plumbing Commands

There were also quite a number of lower level plumbing commands that we encountered in the book.

The first one we encounter is `ls-remote` in <<_pr_refs>> which we use to look at the raw references on the server.

We use `ls-files` in <<_manual_remerge>>, <<_rerere>> and <<_the_index>> to take a more raw look at what your staging area looks like.

We also mention `rev-parse` in <<_branch_references>> to take just about any string and turn it into an object SHA-1.

However, most of the low level plumbing commands we cover are in <<_git_internals>>, which is more or less what the chapter is focused on. We tried to avoid use of them throughout most of the rest of the book.
